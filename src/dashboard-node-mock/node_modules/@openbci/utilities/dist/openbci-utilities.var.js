var OpenBCIUtilities =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 15);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(2)\nvar ieee754 = __webpack_require__(3)\nvar isArray = __webpack_require__(4)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/node-libs-browser/node_modules/buffer/index.js\n// module id = 0\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/base64-js/index.js\n// module id = 2\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ieee754/index.js\n// module id = 3\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/isarray/index.js\n// module id = 4\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer___);\n/**\r\n* Created by ajk on 12/16/15.\r\n* Purpose: This file folds all the constants for the\r\n*     OpenBCI Board\r\n*/\n\n\n\n\n/** Turning channels off */\nconst obciChannelOff1 = '1';\nconst obciChannelOff2 = '2';\nconst obciChannelOff3 = '3';\nconst obciChannelOff4 = '4';\nconst obciChannelOff5 = '5';\nconst obciChannelOff6 = '6';\nconst obciChannelOff7 = '7';\nconst obciChannelOff8 = '8';\nconst obciChannelOff9 = 'q';\nconst obciChannelOff10 = 'w';\nconst obciChannelOff11 = 'e';\nconst obciChannelOff12 = 'r';\nconst obciChannelOff13 = 't';\nconst obciChannelOff14 = 'y';\nconst obciChannelOff15 = 'u';\nconst obciChannelOff16 = 'i';\n\n/** Turn channels on */\nconst obciChannelOn1 = '!';\nconst obciChannelOn2 = '@';\nconst obciChannelOn3 = '#';\nconst obciChannelOn4 = '$';\nconst obciChannelOn5 = '%';\nconst obciChannelOn6 = '^';\nconst obciChannelOn7 = '&';\nconst obciChannelOn8 = '*';\nconst obciChannelOn9 = 'Q';\nconst obciChannelOn10 = 'W';\nconst obciChannelOn11 = 'E';\nconst obciChannelOn12 = 'R';\nconst obciChannelOn13 = 'T';\nconst obciChannelOn14 = 'Y';\nconst obciChannelOn15 = 'U';\nconst obciChannelOn16 = 'I';\n\n/** Test Signal Control Commands\r\n* 1x - Voltage will be 1 * (VREFP - VREFN) / 2.4 mV\r\n* 2x - Voltage will be 2 * (VREFP - VREFN) / 2.4 mV\r\n*/\nconst obciTestSignalConnectToDC = 'p';\nconst obciTestSignalConnectToGround = '0';\nconst obciTestSignalConnectToPulse1xFast = '=';\nconst obciTestSignalConnectToPulse1xSlow = '-';\nconst obciTestSignalConnectToPulse2xFast = ']';\nconst obciTestSignalConnectToPulse2xSlow = '[';\n\n/** Channel Setting Commands */\nconst obciChannelCmdADCNormal = '0';\nconst obciChannelCmdADCShorted = '1';\nconst obciChannelCmdADCBiasDRP = '6';\nconst obciChannelCmdADCBiasDRN = '7';\nconst obciChannelCmdADCBiasMethod = '2';\nconst obciChannelCmdADCMVDD = '3';\nconst obciChannelCmdADCTemp = '4';\nconst obciChannelCmdADCTestSig = '5';\nconst obciChannelCmdBiasInclude = '1';\nconst obciChannelCmdBiasRemove = '0';\nconst obciChannelCmdChannel1 = '1';\nconst obciChannelCmdChannel2 = '2';\nconst obciChannelCmdChannel3 = '3';\nconst obciChannelCmdChannel4 = '4';\nconst obciChannelCmdChannel5 = '5';\nconst obciChannelCmdChannel6 = '6';\nconst obciChannelCmdChannel7 = '7';\nconst obciChannelCmdChannel8 = '8';\nconst obciChannelCmdChannel9 = 'Q';\nconst obciChannelCmdChannel10 = 'W';\nconst obciChannelCmdChannel11 = 'E';\nconst obciChannelCmdChannel12 = 'R';\nconst obciChannelCmdChannel13 = 'T';\nconst obciChannelCmdChannel14 = 'Y';\nconst obciChannelCmdChannel15 = 'U';\nconst obciChannelCmdChannel16 = 'I';\nconst obciChannelCmdGain1 = '0';\nconst obciChannelCmdGain2 = '1';\nconst obciChannelCmdGain4 = '2';\nconst obciChannelCmdGain6 = '3';\nconst obciChannelCmdGain8 = '4';\nconst obciChannelCmdGain12 = '5';\nconst obciChannelCmdGain24 = '6';\nconst obciChannelCmdLatch = 'X';\nconst obciChannelCmdPowerOff = '1';\nconst obciChannelCmdPowerOn = '0';\nconst obciChannelCmdSet = 'x';\nconst obciChannelCmdSRB1Connect = '1';\nconst obciChannelCmdSRB1Diconnect = '0';\nconst obciChannelCmdSRB2Connect = '1';\nconst obciChannelCmdSRB2Diconnect = '0';\n\n/** Channel Setting Helper Strings */\nconst obciStringADCNormal = 'normal';\nconst obciStringADCShorted = 'shorted';\nconst obciStringADCBiasMethod = 'biasMethod';\nconst obciStringADCMvdd = 'mvdd';\nconst obciStringADCTemp = 'temp';\nconst obciStringADCTestSig = 'testSig';\nconst obciStringADCBiasDrp = 'biasDrp';\nconst obciStringADCBiasDrn = 'biasDrn';\n\n/** Default Channel Settings */\nconst obciChannelDefaultAllSet = 'd';\nconst obciChannelDefaultAllGet = 'D';\n\n/** LeadOff Impedance Commands */\nconst obciChannelImpedanceLatch = 'Z';\nconst obciChannelImpedanceSet = 'z';\nconst obciChannelImpedanceTestSignalApplied = '1';\nconst obciChannelImpedanceTestSignalAppliedNot = '0';\n\n/** SD card Commands */\nconst obciSDLogForHour1 = 'G';\nconst obciSDLogForHour2 = 'H';\nconst obciSDLogForHour4 = 'J';\nconst obciSDLogForHour12 = 'K';\nconst obciSDLogForHour24 = 'L';\nconst obciSDLogForMin5 = 'A';\nconst obciSDLogForMin15 = 'S';\nconst obciSDLogForMin30 = 'F';\nconst obciSDLogForSec14 = 'a';\nconst obciSDLogStop = 'j';\n\n/** SD Card String Commands */\nconst obciStringSDHour1 = '1hour';\nconst obciStringSDHour2 = '2hour';\nconst obciStringSDHour4 = '4hour';\nconst obciStringSDHour12 = '12hour';\nconst obciStringSDHour24 = '24hour';\nconst obciStringSDMin5 = '5min';\nconst obciStringSDMin15 = '15min';\nconst obciStringSDMin30 = '30min';\nconst obciStringSDSec14 = '14sec';\n\n/** Stream Data Commands */\nconst obciStreamStart = 'b';\nconst obciStreamStop = 's';\n\n/** Miscellaneous */\nconst obciMiscQueryRegisterSettings = '?';\nconst obciMiscQueryRegisterSettingsChannel1 = 'CH1SET';\nconst obciMiscQueryRegisterSettingsChannel2 = 'CH2SET';\nconst obciMiscQueryRegisterSettingsChannel3 = 'CH3SET';\nconst obciMiscQueryRegisterSettingsChannel4 = 'CH4SET';\nconst obciMiscQueryRegisterSettingsChannel5 = 'CH5SET';\nconst obciMiscQueryRegisterSettingsChannel6 = 'CH6SET';\nconst obciMiscQueryRegisterSettingsChannel7 = 'CH7SET';\nconst obciMiscQueryRegisterSettingsChannel8 = 'CH8SET';\nconst obciMiscSoftReset = 'v';\n\n/** 16 Channel Commands */\nconst obciChannelMaxNumber8 = 'c';\nconst obciChannelMaxNumber16 = 'C';\nconst obciChannelMaxNumber8NoDaisyToRemove = '';\nconst obciChannelMaxNumber8SuccessDaisyRemoved = 'daisy removed';\nconst obciChannelMaxNumber16DaisyAlreadyAttached = '16';\nconst obciChannelMaxNumber16DaisyAttached = 'daisy attached16';\nconst obciChannelMaxNumber16NoDaisyAttached = 'no daisy to attach!8';\n\n/** 60Hz line filter */\nconst obciFilterDisable = 'g';\nconst obciFilterEnable = 'f';\n\n/** Triggers */\nconst obciTrigger = '`';\n\n/** Sync Clocks */\nconst obciSyncTimeSet = '<';\nconst obciSyncTimeSent = ',';\n\n/** Set board mode */\nconst obciBoardModeSet = '/';\nconst obciBoardModeCmdDefault = '0';\nconst obciBoardModeCmdDebug = '1';\nconst obciBoardModeCmdAnalog = '2';\nconst obciBoardModeCmdDigital = '3';\nconst obciBoardModeCmdGetCur = '/';\nconst obciBoardModeAnalog = 'analog';\nconst obciBoardModeDefault = 'default';\nconst obciBoardModeDebug = 'debug';\nconst obciBoardModeDigital = 'digital';\n\n/** Set sample rate */\nconst obciSampleRateSet = '~';\nconst obciSampleRateCmdCyton16000 = '0';\nconst obciSampleRateCmdCyton8000 = '1';\nconst obciSampleRateCmdCyton4000 = '2';\nconst obciSampleRateCmdCyton2000 = '3';\nconst obciSampleRateCmdCyton1000 = '4';\nconst obciSampleRateCmdCyton500 = '5';\nconst obciSampleRateCmdCyton250 = '6';\nconst obciSampleRateCmdGang25600 = '0';\nconst obciSampleRateCmdGang12800 = '1';\nconst obciSampleRateCmdGang6400 = '2';\nconst obciSampleRateCmdGang3200 = '3';\nconst obciSampleRateCmdGang1600 = '4';\nconst obciSampleRateCmdGang800 = '5';\nconst obciSampleRateCmdGang400 = '6';\nconst obciSampleRateCmdGang200 = '7';\nconst obciSampleRateCmdaGetCur = '~';\n\n/** Accel enable/disable commands */\nconst obciAccelStart = 'n';\nconst obciAccelStop = 'N';\n\n/** Wifi Stuff */\nconst obciWifiAttach = '{';\nconst obciWifiRemove = '}';\nconst obciWifiReset = ';';\nconst obciWifiStatus = ':';\n\n/** Radio Key */\nconst obciRadioKey = 0xF0;\n/** Radio Commands */\nconst obciRadioCmdChannelGet = 0x00;\nconst obciRadioCmdChannelSet = 0x01;\nconst obciRadioCmdChannelSetOverride = 0x02;\nconst obciRadioCmdPollTimeGet = 0x03;\nconst obciRadioCmdPollTimeSet = 0x04;\nconst obciRadioCmdBaudRateSetDefault = 0x05;\nconst obciRadioCmdBaudRateSetFast = 0x06;\nconst obciRadioCmdSystemStatus = 0x07;\n\n/** Possible number of channels */\nconst obciNumberOfChannelsCyton = 8;\nconst obciNumberOfChannelsCytonBLE = 2;\nconst obciNumberOfChannelsDaisy = 16;\nconst obciNumberOfChannelsDefault = obciNumberOfChannelsCyton;\nconst obciNumberOfChannelsGanglion = 4;\n\n/** Possible OpenBCI board types */\nconst obciBoardCyton = 'cyton';\nconst obciBoardCytonBLE = 'cytonBLE';\nconst obciBoardDaisy = 'daisy';\nconst obciBoardDefault = 'default';\nconst obciBoardGanglion = 'ganglion';\nconst obciBoardNone = 'none';\n\n/** Possible Simulator Line Noise injections */\nconst obciSimulatorLineNoiseHz60 = '60Hz';\nconst obciSimulatorLineNoiseHz50 = '50Hz';\nconst obciSimulatorLineNoiseNone = 'none';\n\n/** Possible Simulator Fragmentation modes */\nconst obciSimulatorFragmentationRandom = 'random';\nconst obciSimulatorFragmentationFullBuffers = 'fullBuffers';\nconst obciSimulatorFragmentationOneByOne = 'oneByOne';\nconst obciSimulatorFragmentationNone = 'none';\n\n/** Possible Sample Rates */\nconst obciSampleRate1000 = 1000;\nconst obciSampleRate125 = 125;\nconst obciSampleRate12800 = 12800;\nconst obciSampleRate1600 = 1600;\nconst obciSampleRate16000 = 16000;\nconst obciSampleRate200 = 200;\nconst obciSampleRate2000 = 2000;\nconst obciSampleRate250 = 250;\nconst obciSampleRate25600 = 25600;\nconst obciSampleRate3200 = 3200;\nconst obciSampleRate400 = 400;\nconst obciSampleRate4000 = 4000;\nconst obciSampleRate500 = 500;\nconst obciSampleRate6400 = 6400;\nconst obciSampleRate800 = 800;\nconst obciSampleRate8000 = 8000;\n\n/** Max sample number */\nconst obciSampleNumberMax = 255;\n\n/** Packet Size */\nconst obciPacketSize = 33;\nconst obciPacketSizeBLECyton = 20;\nconst obciPacketSizeBLERaw = 12;\n\n/** OpenBCI V3 Standard Packet Positions */\n/**\r\n* 0:[startByte] | 1:[sampleNumber] | 2:[Channel-1.1] | 3:[Channel-1.2] | 4:[Channel-1.3] | 5:[Channel-2.1] | 6:[Channel-2.2] | 7:[Channel-2.3] | 8:[Channel-3.1] | 9:[Channel-3.2] | 10:[Channel-3.3] | 11:[Channel-4.1] | 12:[Channel-4.2] | 13:[Channel-4.3] | 14:[Channel-5.1] | 15:[Channel-5.2] | 16:[Channel-5.3] | 17:[Channel-6.1] | 18:[Channel-6.2] | 19:[Channel-6.3] | 20:[Channel-7.1] | 21:[Channel-7.2] | 22:[Channel-7.3] | 23:[Channel-8.1] | 24:[Channel-8.2] | 25:[Channel-8.3] | 26:[Aux-1.1] | 27:[Aux-1.2] | 28:[Aux-2.1] | 29:[Aux-2.2] | 30:[Aux-3.1] | 31:[Aux-3.2] | 32:StopByte\r\n*/\nconst obciPacketPositionChannelDataStart = 2; // 0:startByte | 1:sampleNumber | [2:4] | [5:7] | [8:10] | [11:13] | [14:16] | [17:19] | [21:23] | [24:26]\nconst obciPacketPositionChannelDataStop = 25; // 24 bytes for channel data\nconst obciPacketPositionSampleNumber = 1;\nconst obciPacketPositionStartByte = 0; // first byte\nconst obciPacketPositionStopByte = 32; // [32]\nconst obciPacketPositionStartAux = 26; // [26,27]:Aux 1 | [28,29]:Aux 2 | [30,31]:Aux 3\nconst obciPacketPositionStopAux = 31; // - - - [30,31]:Aux 3 | 32: Stop byte\nconst obciPacketPositionTimeSyncAuxStart = 26;\nconst obciPacketPositionTimeSyncAuxStop = 28;\nconst obciPacketPositionTimeSyncTimeStart = 28;\nconst obciPacketPositionTimeSyncTimeStop = 32;\n\n/** Notable Bytes */\nconst obciByteStart = 0xA0;\nconst obciByteStop = 0xC0;\n\n/** Errors */\nconst errorInvalidByteLength = 'Invalid Packet Byte Length';\nconst errorInvalidByteStart = 'Invalid Start Byte';\nconst errorInvalidByteStop = 'Invalid Stop Byte';\nconst errorInvalidData = 'Invalid data - try again';\nconst errorInvalidType = 'Invalid type - check comments for input type';\nconst errorMissingRegisterSetting = 'Missing register setting';\nconst errorMissingRequiredProperty = 'Missing property in JSON';\nconst errorNobleAlreadyScanning = 'Scan already under way';\nconst errorNobleNotAlreadyScanning = 'No scan started';\nconst errorNobleNotInPoweredOnState = 'Please turn blue tooth on.';\nconst errorTimeSyncIsNull = \"'this.sync.curSyncObj' must not be null\";\nconst errorTimeSyncNoComma = 'Missed the time sync sent confirmation. Try sync again';\nconst errorUndefinedOrNullInput = 'Undefined or Null Input';\n\n/** Max Master Buffer Size */\nconst obciMasterBufferSize = 4096;\n\n/** Impedance Calculation Variables */\nconst obciLeadOffDriveInAmps = 0.000000006;\nconst obciLeadOffFrequencyHz = 31.5;\n\n/** Command send delay */\nconst obciWriteIntervalDelayMSLong = 50;\nconst obciWriteIntervalDelayMSNone = 0;\nconst obciWriteIntervalDelayMSShort = 10;\n\n/** Impedance */\nconst obciImpedanceTextBad = 'bad';\nconst obciImpedanceTextNone = 'none';\nconst obciImpedanceTextGood = 'good';\nconst obciImpedanceTextInit = 'init';\nconst obciImpedanceTextOk = 'ok';\n\nconst obciImpedanceThresholdGoodMin = 0;\nconst obciImpedanceThresholdGoodMax = 5000;\nconst obciImpedanceThresholdOkMin = 5001;\nconst obciImpedanceThresholdOkMax = 10000;\nconst obciImpedanceThresholdBadMin = 10001;\nconst obciImpedanceThresholdBadMax = 1000000;\n\nconst obciImpedanceSeriesResistor = 2200; // There is a 2.2 k Ohm series resistor that must be subtracted\n\n/** Simulator */\nconst obciSimulatorPortName = 'OpenBCISimulator';\n\n/**\r\n* Stream packet types/codes\r\n*/\nconst obciStreamPacketStandardAccel = 0; // 0000\nconst obciStreamPacketStandardRawAux = 1; // 0001\nconst obciStreamPacketUserDefinedType = 2; // 0010\nconst obciStreamPacketAccelTimeSyncSet = 3; // 0011\nconst obciStreamPacketAccelTimeSynced = 4; // 0100\nconst obciStreamPacketRawAuxTimeSyncSet = 5; // 0101\nconst obciStreamPacketRawAuxTimeSynced = 6; // 0110\nconst obciStreamPacketImpedance = 7; // 0111\n\n/** Time from board */\nconst obciStreamPacketTimeByteSize = 4;\n\n/** Time synced with accel packet */\nconst obciAccelAxisX = 7;\nconst obciAccelAxisY = 8;\nconst obciAccelAxisZ = 9;\n\n/** Firmware version indicator */\nconst obciFirmwareV1 = 'v1';\nconst obciFirmwareV2 = 'v2';\nconst obciFirmwareV3 = 'v3';\n\n/** Parse */\nconst obciParseDaisy = 'Daisy';\nconst obciParseFirmware = 'v2';\nconst obciParseFailure = 'Failure';\nconst obciParseEOT = '$$$';\nconst obciParseSuccess = 'Success';\n\n/** Used in parsing incoming serial data */\nconst obciParsingChannelSettings = 2;\nconst obciParsingEOT = 4;\nconst obciParsingNormal = 3;\nconst obciParsingReset = 0;\nconst obciParsingTimeSyncSent = 1;\n\n/** Timeouts */\nconst obciTimeoutProcessBytes = 500; // 0.5 seconds\n\n/** Simulator Board Configurations */\nconst obciSimulatorRawAux = 'rawAux';\nconst obciSimulatorStandard = 'standard';\n\n/** OpenBCI Radio Limits */\nconst obciRadioChannelMax = 25;\nconst obciRadioChannelMin = 1;\nconst obciRadioPollTimeMax = 255;\nconst obciRadioPollTimeMin = 0;\n\n/** Time sync stuff */\nconst obciTimeSyncArraySize = 10;\nconst obciTimeSyncMultiplierWithSyncConf = 0.9;\nconst obciTimeSyncMultiplierWithoutSyncConf = 0.75;\nconst obciTimeSyncThresholdTransFailureMS = 10; // ms\n\n/** Baud Rates */\nconst obciRadioBaudRateDefault = 115200;\nconst obciRadioBaudRateDefaultStr = 'default';\nconst obciRadioBaudRateFast = 230400;\nconst obciRadioBaudRateFastStr = 'fast';\n\n/** Emitters */\nconst obciEmitterAccelerometer = 'accelerometer';\nconst obciEmitterBlePoweredUp = 'blePoweredOn';\nconst obciEmitterClose = 'close';\nconst obciEmitterDroppedPacket = 'droppedPacket';\nconst obciEmitterEot = 'eot';\nconst obciEmitterError = 'error';\nconst obciEmitterGanglionFound = 'ganglionFound';\nconst obciEmitterHardSet = 'hardSet';\nconst obciEmitterImpedance = 'impedance';\nconst obciEmitterImpedanceArray = 'impedanceArray';\nconst obciEmitterMessage = 'message';\nconst obciEmitterQuery = 'query';\nconst obciEmitterRawDataPacket = 'rawDataPacket';\nconst obciEmitterReady = 'ready';\nconst obciEmitterRFduino = 'rfduino';\nconst obciEmitterSample = 'sample';\nconst obciEmitterScanStopped = 'scanStopped';\nconst obciEmitterSynced = 'synced';\nconst obciEmitterWifiShield = 'wifiShield';\n\n/** Accel packets */\nconst obciGanglionAccelAxisX = 1;\nconst obciGanglionAccelAxisY = 2;\nconst obciGanglionAccelAxisZ = 3;\n\n/** Accel scale factor */\nconst obciGanglionAccelScaleFactor = 0.016; // mG per count\n\n/** Ganglion */\nconst obciGanglionBleSearchTime = 20000; // ms\nconst obciGanglionByteIdUncompressed = 0;\nconst obciGanglionByteId18Bit = {\n  max: 100,\n  min: 1\n};\nconst obciGanglionByteId19Bit = {\n  max: 200,\n  min: 101\n};\nconst obciGanglionByteIdImpedanceChannel1 = 201;\nconst obciGanglionByteIdImpedanceChannel2 = 202;\nconst obciGanglionByteIdImpedanceChannel3 = 203;\nconst obciGanglionByteIdImpedanceChannel4 = 204;\nconst obciGanglionByteIdImpedanceChannelReference = 205;\nconst obciGanglionByteIdMultiPacket = 206;\nconst obciGanglionByteIdMultiPacketStop = 207;\nconst obciGanglionPacketSize = 20;\nconst obciGanglionSamplesPerPacket = 2;\nconst obciGanglionPacket18Bit = {\n  auxByte: 20,\n  byteId: 0,\n  dataStart: 1,\n  dataStop: 19\n};\nconst obciGanglionPacket19Bit = {\n  byteId: 0,\n  dataStart: 1,\n  dataStop: 20\n};\nconst obciGanglionMCP3912Gain = 51.0; // assumed gain setting for MCP3912.  NEEDS TO BE ADJUSTABLE JM\nconst obciGanglionMCP3912Vref = 1.2; // reference voltage for ADC in MCP3912 set in hardware\nconst obciGanglionPrefix = 'Ganglion';\nconst obciGanglionSyntheticDataEnable = 't';\nconst obciGanglionSyntheticDataDisable = 'T';\nconst obciGanglionImpedanceStart = 'z';\nconst obciGanglionImpedanceStop = 'Z';\nconst obciGanglionScaleFactorPerCountVolts = obciGanglionMCP3912Vref / (8388607.0 * obciGanglionMCP3912Gain * 1.5);\n\n/** Simblee */\nconst simbleeUuidService = 'fe84';\nconst simbleeUuidReceive = '2d30c082f39f4ce6923f3484ea480596';\nconst simbleeUuidSend = '2d30c083f39f4ce6923f3484ea480596';\nconst simbleeUuidDisconnect = '2d30c084f39f4ce6923f3484ea480596';\n\n/** RFduino BLE UUID */\nconst rfduinoUuidService = '2220';\nconst rfduinoUuidReceive = '2221';\nconst rfduinoUuidSend = '2222';\nconst rfduinoUuidSendTwo = '2223';\n\n/** Cyton BLE */\nconst obciCytonBLESamplesPerPacket = 3;\n\n/** Noble */\nconst obciNobleEmitterPeripheralConnect = 'connect';\nconst obciNobleEmitterPeripheralDisconnect = 'disconnect';\nconst obciNobleEmitterPeripheralDiscover = 'discover';\nconst obciNobleEmitterPeripheralServicesDiscover = 'servicesDiscover';\nconst obciNobleEmitterServiceCharacteristicsDiscover = 'characteristicsDiscover';\nconst obciNobleEmitterServiceRead = 'read';\nconst obciNobleEmitterDiscover = 'discover';\nconst obciNobleEmitterScanStart = 'scanStart';\nconst obciNobleEmitterScanStop = 'scanStop';\nconst obciNobleEmitterStateChange = 'stateChange';\nconst obciNobleStatePoweredOn = 'poweredOn';\n\n/** Protocols */\nconst obciProtocolBLE = 'ble';\nconst obciProtocolSerial = 'serial';\nconst obciProtocolWifi = 'wifi';\n\n/** Register Query on Cyton */\nconst obciRegisterQueryAccelerometerFirmwareV1 = '\\nLIS3DH Registers\\n0x07.0\\n0x08.0\\n0x09.0\\n0x0A.0\\n0x0B.0\\n0x0C.0\\n0x0D.0\\n0x0E.0\\n0x0F.33\\n\\n0x1F.0\\n0x20.8\\n0x21.0\\n0x22.0\\n0x23.18\\n0x24.0\\n0x25.0\\n0x26.0\\n0x27.0\\n0x28.0\\n0x29.0\\n0x2A.0\\n0x2B.0\\n0x2C.0\\n0x2D.0\\n0x2E.0\\n0x2F.20\\n0x30.0\\n0x31.0\\n0x32.0\\n0x33.0\\n\\n0x38.0\\n0x39.0\\n0x3A.0\\n0x3B.0\\n0x3C.0\\n0x3D.0\\n';\nconst obciRegisterQueryAccelerometerFirmwareV3 = '\\nLIS3DH Registers\\n0x07 00\\n0x08 00\\n0x09 00\\n0x0A 00\\n0x0B 00\\n0x0C 00\\n0x0D 00\\n0x0E 00\\n0x0F 33\\n\\n0x1F 00\\n0x20 08\\n0x21 00\\n0x22 00\\n0x23 18\\n0x24 00\\n0x25 00\\n0x26 00\\n0x27 00\\n0x28 00\\n0x29 00\\n0x2A 00\\n0x2B 00\\n0x2C 00\\n0x2D 00\\n0x2E 00\\n0x2F 20\\n0x30 00\\n0x31 00\\n0x32 00\\n0x33 00\\n\\n0x38 00\\n0x39 00\\n0x3A 00\\n0x3B 00\\n0x3C 00\\n0x3D 00\\n';\nconst obciRegisterQueryCyton = '\\nBoard ADS Registers\\nADS_ID, 00, 3E, 0, 0, 1, 1, 1, 1, 1, 0\\nCONFIG1, 01, 96, 1, 0, 0, 1, 0, 1, 1, 0\\nCONFIG2, 02, C0, 1, 1, 0, 0, 0, 0, 0, 0\\nCONFIG3, 03, EC, 1, 1, 1, 0, 1, 1, 0, 0\\nLOFF, 04, 02, 0, 0, 0, 0, 0, 0, 1, 0\\nCH1SET, 05, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH2SET, 06, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH3SET, 07, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH4SET, 08, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH5SET, 09, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH6SET, 0A, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH7SET, 0B, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH8SET, 0C, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nBIAS_SENSP, 0D, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nBIAS_SENSN, 0E, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nLOFF_SENSP, 0F, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_SENSN, 10, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_FLIP, 11, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATP, 12, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATN, 13, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nGPIO, 14, 0F, 0, 0, 0, 0, 1, 1, 1, 1\\nMISC1, 15, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nMISC2, 16, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nCONFIG4, 17, 00, 0, 0, 0, 0, 0, 0, 0, 0\\n';\nconst obciRegisterQueryCytonDaisy = '\\nDaisy ADS Registers\\nADS_ID, 00, 3E, 0, 0, 1, 1, 1, 1, 1, 0\\nCONFIG1, 01, 96, 1, 0, 0, 1, 0, 1, 1, 0\\nCONFIG2, 02, C0, 1, 1, 0, 0, 0, 0, 0, 0\\nCONFIG3, 03, EC, 1, 1, 1, 0, 1, 1, 0, 0\\nLOFF, 04, 02, 0, 0, 0, 0, 0, 0, 1, 0\\nCH1SET, 05, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH2SET, 06, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH3SET, 07, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH4SET, 08, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH5SET, 09, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH6SET, 0A, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH7SET, 0B, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nCH8SET, 0C, 68, 0, 1, 1, 0, 1, 0, 0, 0\\nBIAS_SENSP, 0D, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nBIAS_SENSN, 0E, FF, 1, 1, 1, 1, 1, 1, 1, 1\\nLOFF_SENSP, 0F, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_SENSN, 10, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_FLIP, 11, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATP, 12, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nLOFF_STATN, 13, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nGPIO, 14, 0F, 0, 0, 0, 0, 1, 1, 1, 1\\nMISC1, 15, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nMISC2, 16, 00, 0, 0, 0, 0, 0, 0, 0, 0\\nCONFIG4, 17, 00, 0, 0, 0, 0, 0, 0, 0, 0\\n';\nconst obciRegisterQueryNameMISC1 = 'MISC1';\nconst obciRegisterQueryNameBIASSENSP = 'BIAS_SENSP';\nconst obciRegisterQueryNameCHnSET = ['CH1SET', 'CH2SET', 'CH3SET', 'CH4SET', 'CH5SET', 'CH6SET', 'CH7SET', 'CH8SET'];\nconst obciRegisterQuerySizeCytonFirmwareV1 = obciRegisterQueryCyton.length + obciRegisterQueryAccelerometerFirmwareV1.length;\nconst obciRegisterQuerySizeCytonDaisyFirmwareV1 = obciRegisterQueryCyton.length + obciRegisterQueryCytonDaisy.length + obciRegisterQueryAccelerometerFirmwareV1.length;\nconst obciRegisterQuerySizeCytonFirmwareV3 = obciRegisterQueryCyton.length + obciRegisterQueryAccelerometerFirmwareV3.length;\nconst obciRegisterQuerySizeCytonDaisyFirmwareV3 = obciRegisterQueryCyton.length + obciRegisterQueryCytonDaisy.length + obciRegisterQueryAccelerometerFirmwareV3.length;\n\nconst constantsModule = {\n  /** Turning channels off */\n  OBCIChannelOff1: obciChannelOff1,\n  OBCIChannelOff2: obciChannelOff2,\n  OBCIChannelOff3: obciChannelOff3,\n  OBCIChannelOff4: obciChannelOff4,\n  OBCIChannelOff5: obciChannelOff5,\n  OBCIChannelOff6: obciChannelOff6,\n  OBCIChannelOff7: obciChannelOff7,\n  OBCIChannelOff8: obciChannelOff8,\n  OBCIChannelOff9: obciChannelOff9,\n  OBCIChannelOff10: obciChannelOff10,\n  OBCIChannelOff11: obciChannelOff11,\n  OBCIChannelOff12: obciChannelOff12,\n  OBCIChannelOff13: obciChannelOff13,\n  OBCIChannelOff14: obciChannelOff14,\n  OBCIChannelOff15: obciChannelOff15,\n  OBCIChannelOff16: obciChannelOff16,\n  /**\r\n  * Purpose: To get the proper command to turn a channel off\r\n  * @param channelNumber - A number (1-16) of the desired channel\r\n  * @returns {Promise}\r\n  */\n  commandChannelOff: function (channelNumber) {\n    return new Promise(function (resolve, reject) {\n      switch (channelNumber) {\n        case 1:\n          resolve(obciChannelOff1);\n          break;\n        case 2:\n          resolve(obciChannelOff2);\n          break;\n        case 3:\n          resolve(obciChannelOff3);\n          break;\n        case 4:\n          resolve(obciChannelOff4);\n          break;\n        case 5:\n          resolve(obciChannelOff5);\n          break;\n        case 6:\n          resolve(obciChannelOff6);\n          break;\n        case 7:\n          resolve(obciChannelOff7);\n          break;\n        case 8:\n          resolve(obciChannelOff8);\n          break;\n        case 9:\n          resolve(obciChannelOff9);\n          break;\n        case 10:\n          resolve(obciChannelOff10);\n          break;\n        case 11:\n          resolve(obciChannelOff11);\n          break;\n        case 12:\n          resolve(obciChannelOff12);\n          break;\n        case 13:\n          resolve(obciChannelOff13);\n          break;\n        case 14:\n          resolve(obciChannelOff14);\n          break;\n        case 15:\n          resolve(obciChannelOff15);\n          break;\n        case 16:\n          resolve(obciChannelOff16);\n          break;\n        default:\n          reject(Error('Error [commandChannelOff]: Invalid Channel Number'));\n          break;\n      }\n    });\n  },\n  /** Turning channels on */\n  OBCIChannelOn1: obciChannelOn1,\n  OBCIChannelOn2: obciChannelOn2,\n  OBCIChannelOn3: obciChannelOn3,\n  OBCIChannelOn4: obciChannelOn4,\n  OBCIChannelOn5: obciChannelOn5,\n  OBCIChannelOn6: obciChannelOn6,\n  OBCIChannelOn7: obciChannelOn7,\n  OBCIChannelOn8: obciChannelOn8,\n  OBCIChannelOn9: obciChannelOn9,\n  OBCIChannelOn10: obciChannelOn10,\n  OBCIChannelOn11: obciChannelOn11,\n  OBCIChannelOn12: obciChannelOn12,\n  OBCIChannelOn13: obciChannelOn13,\n  OBCIChannelOn14: obciChannelOn14,\n  OBCIChannelOn15: obciChannelOn15,\n  OBCIChannelOn16: obciChannelOn16,\n  commandChannelOn: function (channelNumber) {\n    return new Promise(function (resolve, reject) {\n      switch (channelNumber) {\n        case 1:\n          resolve(obciChannelOn1);\n          break;\n        case 2:\n          resolve(obciChannelOn2);\n          break;\n        case 3:\n          resolve(obciChannelOn3);\n          break;\n        case 4:\n          resolve(obciChannelOn4);\n          break;\n        case 5:\n          resolve(obciChannelOn5);\n          break;\n        case 6:\n          resolve(obciChannelOn6);\n          break;\n        case 7:\n          resolve(obciChannelOn7);\n          break;\n        case 8:\n          resolve(obciChannelOn8);\n          break;\n        case 9:\n          resolve(obciChannelOn9);\n          break;\n        case 10:\n          resolve(obciChannelOn10);\n          break;\n        case 11:\n          resolve(obciChannelOn11);\n          break;\n        case 12:\n          resolve(obciChannelOn12);\n          break;\n        case 13:\n          resolve(obciChannelOn13);\n          break;\n        case 14:\n          resolve(obciChannelOn14);\n          break;\n        case 15:\n          resolve(obciChannelOn15);\n          break;\n        case 16:\n          resolve(obciChannelOn16);\n          break;\n        default:\n          reject(Error('Error [commandChannelOn]: Invalid Channel Number'));\n          break;\n      }\n    });\n  },\n  /** Test Signal Control Commands */\n  OBCITestSignalConnectToDC: obciTestSignalConnectToDC,\n  OBCITestSignalConnectToGround: obciTestSignalConnectToGround,\n  OBCITestSignalConnectToPulse1xFast: obciTestSignalConnectToPulse1xFast,\n  OBCITestSignalConnectToPulse1xSlow: obciTestSignalConnectToPulse1xSlow,\n  OBCITestSignalConnectToPulse2xFast: obciTestSignalConnectToPulse2xFast,\n  OBCITestSignalConnectToPulse2xSlow: obciTestSignalConnectToPulse2xSlow,\n  getTestSignalCommand: signal => {\n    return new Promise((resolve, reject) => {\n      switch (signal) {\n        case 'dc':\n          resolve(obciTestSignalConnectToDC);\n          break;\n        case 'ground':\n          resolve(obciTestSignalConnectToGround);\n          break;\n        case 'pulse1xFast':\n          resolve(obciTestSignalConnectToPulse1xFast);\n          break;\n        case 'pulse1xSlow':\n          resolve(obciTestSignalConnectToPulse1xSlow);\n          break;\n        case 'pulse2xFast':\n          resolve(obciTestSignalConnectToPulse2xFast);\n          break;\n        case 'pulse2xSlow':\n          resolve(obciTestSignalConnectToPulse2xSlow);\n          break;\n        case 'none':\n          resolve(obciChannelDefaultAllSet);\n          break;\n        default:\n          reject(Error('Invalid selection! Check your spelling.'));\n          break;\n      }\n    });\n  },\n  /** Channel Setting Commands */\n  OBCIChannelCmdADCNormal: obciChannelCmdADCNormal,\n  OBCIChannelCmdADCShorted: obciChannelCmdADCShorted,\n  OBCIChannelCmdADCBiasDRP: obciChannelCmdADCBiasDRP,\n  OBCIChannelCmdADCBiasDRN: obciChannelCmdADCBiasDRN,\n  OBCIChannelCmdADCBiasMethod: obciChannelCmdADCBiasMethod,\n  OBCIChannelCmdADCMVDD: obciChannelCmdADCMVDD,\n  OBCIChannelCmdADCTemp: obciChannelCmdADCTemp,\n  OBCIChannelCmdADCTestSig: obciChannelCmdADCTestSig,\n  OBCIChannelCmdBiasInclude: obciChannelCmdBiasInclude,\n  OBCIChannelCmdBiasRemove: obciChannelCmdBiasRemove,\n  OBCIChannelCmdChannel1: obciChannelCmdChannel1,\n  OBCIChannelCmdChannel2: obciChannelCmdChannel2,\n  OBCIChannelCmdChannel3: obciChannelCmdChannel3,\n  OBCIChannelCmdChannel4: obciChannelCmdChannel4,\n  OBCIChannelCmdChannel5: obciChannelCmdChannel5,\n  OBCIChannelCmdChannel6: obciChannelCmdChannel6,\n  OBCIChannelCmdChannel7: obciChannelCmdChannel7,\n  OBCIChannelCmdChannel8: obciChannelCmdChannel8,\n  OBCIChannelCmdChannel9: obciChannelCmdChannel9,\n  OBCIChannelCmdChannel10: obciChannelCmdChannel10,\n  OBCIChannelCmdChannel11: obciChannelCmdChannel11,\n  OBCIChannelCmdChannel12: obciChannelCmdChannel12,\n  OBCIChannelCmdChannel13: obciChannelCmdChannel13,\n  OBCIChannelCmdChannel14: obciChannelCmdChannel14,\n  OBCIChannelCmdChannel15: obciChannelCmdChannel15,\n  OBCIChannelCmdChannel16: obciChannelCmdChannel16,\n  commandChannelForCmd,\n  OBCIChannelCmdGain1: obciChannelCmdGain1,\n  OBCIChannelCmdGain2: obciChannelCmdGain2,\n  OBCIChannelCmdGain4: obciChannelCmdGain4,\n  OBCIChannelCmdGain6: obciChannelCmdGain6,\n  OBCIChannelCmdGain8: obciChannelCmdGain8,\n  OBCIChannelCmdGain12: obciChannelCmdGain12,\n  OBCIChannelCmdGain24: obciChannelCmdGain24,\n  commandForGain,\n  gainForCommand,\n  OBCIChannelCmdLatch: obciChannelCmdLatch,\n  OBCIChannelCmdPowerOff: obciChannelCmdPowerOff,\n  OBCIChannelCmdPowerOn: obciChannelCmdPowerOn,\n  OBCIChannelCmdSet: obciChannelCmdSet,\n  OBCIChannelCmdSRB1Connect: obciChannelCmdSRB1Connect,\n  OBCIChannelCmdSRB1Diconnect: obciChannelCmdSRB1Diconnect,\n  OBCIChannelCmdSRB2Connect: obciChannelCmdSRB2Connect,\n  OBCIChannelCmdSRB2Diconnect: obciChannelCmdSRB2Diconnect,\n  /** Channel Settings Object */\n  channelSettingsObjectDefault,\n  /**\r\n   * @param numberOfChannels {Number}\r\n   * @returns {Array}\r\n   */\n  channelSettingsArrayInit: numberOfChannels => {\n    var newChannelSettingsArray = [];\n    for (var i = 0; i < numberOfChannels; i++) {\n      newChannelSettingsArray.push(channelSettingsObjectDefault(i));\n    }\n    return newChannelSettingsArray;\n  },\n  /** Channel Setting Helper Strings */\n  OBCIStringADCNormal: obciStringADCNormal,\n  OBCIStringADCShorted: obciStringADCShorted,\n  OBCIStringADCBiasMethod: obciStringADCBiasMethod,\n  OBCIStringADCMvdd: obciStringADCMvdd,\n  OBCIStringADCTemp: obciStringADCTemp,\n  OBCIStringADCTestSig: obciStringADCTestSig,\n  OBCIStringADCBiasDrp: obciStringADCBiasDrp,\n  OBCIStringADCBiasDrn: obciStringADCBiasDrn,\n  /**\r\n  * @description To convert a string like 'normal' to the correct command (i.e. '1')\r\n  * @param adcString\r\n  * @returns {Promise}\r\n  * @author AJ Keller (@pushtheworldllc)\r\n  */\n  commandForADCString,\n  inputTypeForCommand,\n  /** Default Channel Settings */\n  OBCIChannelDefaultAllSet: obciChannelDefaultAllSet,\n  OBCIChannelDefaultAllGet: obciChannelDefaultAllGet,\n  /** LeadOff Impedance Commands */\n  OBCIChannelImpedanceLatch: obciChannelImpedanceLatch,\n  OBCIChannelImpedanceSet: obciChannelImpedanceSet,\n  OBCIChannelImpedanceTestSignalApplied: obciChannelImpedanceTestSignalApplied,\n  OBCIChannelImpedanceTestSignalAppliedNot: obciChannelImpedanceTestSignalAppliedNot,\n  /** SD card Commands */\n  OBCISDLogForHour1: obciSDLogForHour1,\n  OBCISDLogForHour2: obciSDLogForHour2,\n  OBCISDLogForHour4: obciSDLogForHour4,\n  OBCISDLogForHour12: obciSDLogForHour12,\n  OBCISDLogForHour24: obciSDLogForHour24,\n  OBCISDLogForMin5: obciSDLogForMin5,\n  OBCISDLogForMin15: obciSDLogForMin15,\n  OBCISDLogForMin30: obciSDLogForMin30,\n  OBCISDLogForSec14: obciSDLogForSec14,\n  OBCISDLogStop: obciSDLogStop,\n  /** SD Card String Commands */\n  OBCIStringSDHour1: obciStringSDHour1,\n  OBCIStringSDHour2: obciStringSDHour2,\n  OBCIStringSDHour4: obciStringSDHour4,\n  OBCIStringSDHour12: obciStringSDHour12,\n  OBCIStringSDHour24: obciStringSDHour24,\n  OBCIStringSDMin5: obciStringSDMin5,\n  OBCIStringSDMin15: obciStringSDMin15,\n  OBCIStringSDMin30: obciStringSDMin30,\n  OBCIStringSDSec14: obciStringSDSec14,\n  /**\r\n  * @description Converts a sd string into the proper setting.\r\n  * @param stringCommand {String} - The length of time you want to record to the SD for.\r\n  * @returns {Promise} The command to send to the Board, returns an error on improper `stringCommand`\r\n  */\n  sdSettingForString: stringCommand => {\n    return new Promise((resolve, reject) => {\n      switch (stringCommand) {\n        case obciStringSDHour1:\n          resolve(obciSDLogForHour1);\n          break;\n        case obciStringSDHour2:\n          resolve(obciSDLogForHour2);\n          break;\n        case obciStringSDHour4:\n          resolve(obciSDLogForHour4);\n          break;\n        case obciStringSDHour12:\n          resolve(obciSDLogForHour12);\n          break;\n        case obciStringSDHour24:\n          resolve(obciSDLogForHour24);\n          break;\n        case obciStringSDMin5:\n          resolve(obciSDLogForMin5);\n          break;\n        case obciStringSDMin15:\n          resolve(obciSDLogForMin15);\n          break;\n        case obciStringSDMin30:\n          resolve(obciSDLogForMin30);\n          break;\n        case obciStringSDSec14:\n          resolve(obciSDLogForSec14);\n          break;\n        default:\n          reject(Error(TypeError));\n          break;\n      }\n    });\n  },\n  /** Stream Data Commands */\n  OBCIStreamStart: obciStreamStart,\n  OBCIStreamStop: obciStreamStop,\n  /** Accel enable/disable commands */\n  OBCIAccelStart: obciAccelStart,\n  OBCIAccelStop: obciAccelStop,\n  /** Miscellaneous */\n  OBCIMiscQueryRegisterSettings: obciMiscQueryRegisterSettings,\n  OBCIMiscQueryRegisterSettingsChannel1: obciMiscQueryRegisterSettingsChannel1,\n  OBCIMiscQueryRegisterSettingsChannel2: obciMiscQueryRegisterSettingsChannel2,\n  OBCIMiscQueryRegisterSettingsChannel3: obciMiscQueryRegisterSettingsChannel3,\n  OBCIMiscQueryRegisterSettingsChannel4: obciMiscQueryRegisterSettingsChannel4,\n  OBCIMiscQueryRegisterSettingsChannel5: obciMiscQueryRegisterSettingsChannel5,\n  OBCIMiscQueryRegisterSettingsChannel6: obciMiscQueryRegisterSettingsChannel6,\n  OBCIMiscQueryRegisterSettingsChannel7: obciMiscQueryRegisterSettingsChannel7,\n  OBCIMiscQueryRegisterSettingsChannel8: obciMiscQueryRegisterSettingsChannel8,\n  channelSettingsKeyForChannel: channelNumber => {\n    return new Promise((resolve, reject) => {\n      switch (channelNumber) {\n        case 1:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel1));\n          break;\n        case 2:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel2));\n          break;\n        case 3:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel3));\n          break;\n        case 4:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel4));\n          break;\n        case 5:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel5));\n          break;\n        case 6:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel6));\n          break;\n        case 7:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel7));\n          break;\n        case 8:\n          resolve(new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](obciMiscQueryRegisterSettingsChannel8));\n          break;\n        default:\n          reject(Error('Invalid channel number'));\n          break;\n      }\n    });\n  },\n  OBCIMiscSoftReset: obciMiscSoftReset,\n  /** 16 Channel Commands */\n  OBCIChannelMaxNumber8: obciChannelMaxNumber8,\n  OBCIChannelMaxNumber16: obciChannelMaxNumber16,\n  OBCIChannelMaxNumber8NoDaisyToRemove: obciChannelMaxNumber8NoDaisyToRemove,\n  OBCIChannelMaxNumber8SuccessDaisyRemoved: obciChannelMaxNumber8SuccessDaisyRemoved,\n  OBCIChannelMaxNumber16DaisyAlreadyAttached: obciChannelMaxNumber16DaisyAlreadyAttached,\n  OBCIChannelMaxNumber16DaisyAttached: obciChannelMaxNumber16DaisyAttached,\n  OBCIChannelMaxNumber16NoDaisyAttached: obciChannelMaxNumber16NoDaisyAttached,\n  /** Filters */\n  OBCIFilterDisable: obciFilterDisable,\n  OBCIFilterEnable: obciFilterEnable,\n  /** Triggers */\n  OBCITrigger: obciTrigger,\n  /** Possible number of channels */\n  OBCINumberOfChannelsCyton: obciNumberOfChannelsCyton,\n  OBCINumberOfChannelsCytonBLE: obciNumberOfChannelsCytonBLE,\n  OBCINumberOfChannelsDaisy: obciNumberOfChannelsDaisy,\n  OBCINumberOfChannelsDefault: obciNumberOfChannelsDefault,\n  OBCINumberOfChannelsGanglion: obciNumberOfChannelsGanglion,\n  /** Possible OpenBCI board types */\n  OBCIBoardCyton: obciBoardCyton,\n  OBCIBoardCytonBLE: obciBoardCytonBLE,\n  OBCIBoardDaisy: obciBoardDaisy,\n  OBCIBoardDefault: obciBoardDefault,\n  OBCIBoardGanglion: obciBoardGanglion,\n  OBCIBoardNone: obciBoardNone,\n  numberOfChannelsForBoardType: boardType => {\n    switch (boardType) {\n      case obciBoardDaisy:\n        return obciNumberOfChannelsDaisy;\n      case obciBoardGanglion:\n        return obciNumberOfChannelsGanglion;\n      case obciBoardNone:\n        return 0;\n      case obciBoardCytonBLE:\n        return obciNumberOfChannelsCytonBLE;\n      case obciBoardCyton:\n      default:\n        return obciNumberOfChannelsDefault;\n    }\n  },\n  boardTypeForNumberOfChannels: numberOfChannels => {\n    switch (numberOfChannels) {\n      case obciNumberOfChannelsDaisy:\n        return obciBoardDaisy;\n      case obciNumberOfChannelsGanglion:\n        return obciBoardGanglion;\n      case 0:\n        return obciBoardNone;\n      case obciNumberOfChannelsCytonBLE:\n        return obciBoardCytonBLE;\n      case obciNumberOfChannelsDefault:\n      default:\n        return obciBoardCyton;\n    }\n  },\n  /** Possible Sample Rates */\n  OBCISampleRate1000: obciSampleRate1000,\n  OBCISampleRate125: obciSampleRate125,\n  OBCISampleRate12800: obciSampleRate12800,\n  OBCISampleRate1600: obciSampleRate1600,\n  OBCISampleRate16000: obciSampleRate16000,\n  OBCISampleRate200: obciSampleRate200,\n  OBCISampleRate2000: obciSampleRate2000,\n  OBCISampleRate250: obciSampleRate250,\n  OBCISampleRate25600: obciSampleRate25600,\n  OBCISampleRate3200: obciSampleRate3200,\n  OBCISampleRate400: obciSampleRate400,\n  OBCISampleRate4000: obciSampleRate4000,\n  OBCISampleRate500: obciSampleRate500,\n  OBCISampleRate6400: obciSampleRate6400,\n  OBCISampleRate800: obciSampleRate800,\n  OBCISampleRate8000: obciSampleRate8000,\n  /** Max sample number */\n  OBCISampleNumberMax: obciSampleNumberMax,\n  /** Packet Size */\n  OBCIPacketSize: obciPacketSize,\n  OBCIPacketSizeBLECyton: obciPacketSizeBLECyton,\n  OBCIPacketSizeBLERaw: obciPacketSizeBLERaw,\n  /** Notable Bytes */\n  OBCIByteStart: obciByteStart,\n  OBCIByteStop: obciByteStop,\n  /** Errors */\n  OBCIErrorInvalidByteLength: errorInvalidByteLength,\n  OBCIErrorInvalidByteStart: errorInvalidByteStart,\n  OBCIErrorInvalidByteStop: errorInvalidByteStop,\n  OBCIErrorInvalidData: errorInvalidData,\n  OBCIErrorInvalidType: errorInvalidType,\n  OBCIErrorMissingRegisterSetting: errorMissingRegisterSetting,\n  OBCIErrorMissingRequiredProperty: errorMissingRequiredProperty,\n  OBCIErrorNobleAlreadyScanning: errorNobleAlreadyScanning,\n  OBCIErrorNobleNotAlreadyScanning: errorNobleNotAlreadyScanning,\n  OBCIErrorNobleNotInPoweredOnState: errorNobleNotInPoweredOnState,\n  OBCIErrorTimeSyncIsNull: errorTimeSyncIsNull,\n  OBCIErrorTimeSyncNoComma: errorTimeSyncNoComma,\n  OBCIErrorUndefinedOrNullInput: errorUndefinedOrNullInput,\n  /** Max Master Buffer Size */\n  OBCIMasterBufferSize: obciMasterBufferSize,\n  /** Impedance Calculation Variables */\n  OBCILeadOffDriveInAmps: obciLeadOffDriveInAmps,\n  OBCILeadOffFrequencyHz: obciLeadOffFrequencyHz,\n  /** Channel Setter Maker */\n  getChannelSetter: channelSetter,\n  /** Impedance Setter Maker */\n  getImpedanceSetter: impedanceSetter,\n  /** Sample Rate Setter Maker */\n  getSampleRateSetter: sampleRateSetter,\n  /** Board Mode Setter Maker */\n  getBoardModeSetter: boardModeSetter,\n  /** Command send delay */\n  OBCIWriteIntervalDelayMSLong: obciWriteIntervalDelayMSLong,\n  OBCIWriteIntervalDelayMSNone: obciWriteIntervalDelayMSNone,\n  OBCIWriteIntervalDelayMSShort: obciWriteIntervalDelayMSShort,\n  /** Sync Clocks */\n  OBCISyncTimeSent: obciSyncTimeSent,\n  OBCISyncTimeSet: obciSyncTimeSet,\n  /** Radio Key */\n  OBCIRadioKey: obciRadioKey,\n  /** Radio Commands */\n  OBCIRadioCmdChannelGet: obciRadioCmdChannelGet,\n  OBCIRadioCmdChannelSet: obciRadioCmdChannelSet,\n  OBCIRadioCmdChannelSetOverride: obciRadioCmdChannelSetOverride,\n  OBCIRadioCmdPollTimeGet: obciRadioCmdPollTimeGet,\n  OBCIRadioCmdPollTimeSet: obciRadioCmdPollTimeSet,\n  OBCIRadioCmdBaudRateSetDefault: obciRadioCmdBaudRateSetDefault,\n  OBCIRadioCmdBaudRateSetFast: obciRadioCmdBaudRateSetFast,\n  OBCIRadioCmdSystemStatus: obciRadioCmdSystemStatus,\n  /** Impedance */\n  OBCIImpedanceTextBad: obciImpedanceTextBad,\n  OBCIImpedanceTextGood: obciImpedanceTextGood,\n  OBCIImpedanceTextInit: obciImpedanceTextInit,\n  OBCIImpedanceTextOk: obciImpedanceTextOk,\n  OBCIImpedanceTextNone: obciImpedanceTextNone,\n  OBCIImpedanceThresholdBadMax: obciImpedanceThresholdBadMax,\n  OBCIImpedanceSeriesResistor: obciImpedanceSeriesResistor,\n  getTextForRawImpedance: value => {\n    if (value > obciImpedanceThresholdGoodMin && value < obciImpedanceThresholdGoodMax) {\n      return obciImpedanceTextGood;\n    } else if (value > obciImpedanceThresholdOkMin && value < obciImpedanceThresholdOkMax) {\n      return obciImpedanceTextOk;\n    } else if (value > obciImpedanceThresholdBadMin && value < obciImpedanceThresholdBadMax) {\n      return obciImpedanceTextBad;\n    } else {\n      return obciImpedanceTextNone;\n    }\n  },\n  /** Simulator */\n  OBCISimulatorPortName: obciSimulatorPortName,\n  /**\r\n  * Stream packet types/codes\r\n  */\n  OBCIStreamPacketStandardAccel: obciStreamPacketStandardAccel,\n  OBCIStreamPacketStandardRawAux: obciStreamPacketStandardRawAux,\n  OBCIStreamPacketUserDefinedType: obciStreamPacketUserDefinedType,\n  OBCIStreamPacketAccelTimeSyncSet: obciStreamPacketAccelTimeSyncSet,\n  OBCIStreamPacketAccelTimeSynced: obciStreamPacketAccelTimeSynced,\n  OBCIStreamPacketRawAuxTimeSyncSet: obciStreamPacketRawAuxTimeSyncSet,\n  OBCIStreamPacketRawAuxTimeSynced: obciStreamPacketRawAuxTimeSynced,\n  OBCIStreamPacketImpedance: obciStreamPacketImpedance,\n  /** fun funcs */\n  isNumber,\n  isBoolean,\n  isString,\n  isUndefined,\n  isNull,\n  /** OpenBCI V3 Standard Packet Positions */\n  OBCIPacketPositionStartByte: obciPacketPositionStartByte,\n  OBCIPacketPositionStopByte: obciPacketPositionStopByte,\n  OBCIPacketPositionStartAux: obciPacketPositionStartAux,\n  OBCIPacketPositionStopAux: obciPacketPositionStopAux,\n  OBCIPacketPositionChannelDataStart: obciPacketPositionChannelDataStart,\n  OBCIPacketPositionChannelDataStop: obciPacketPositionChannelDataStop,\n  OBCIPacketPositionSampleNumber: obciPacketPositionSampleNumber,\n  OBCIPacketPositionTimeSyncAuxStart: obciPacketPositionTimeSyncAuxStart,\n  OBCIPacketPositionTimeSyncAuxStop: obciPacketPositionTimeSyncAuxStop,\n  OBCIPacketPositionTimeSyncTimeStart: obciPacketPositionTimeSyncTimeStart,\n  OBCIPacketPositionTimeSyncTimeStop: obciPacketPositionTimeSyncTimeStop,\n  /** Possible Simulator Line Noise injections */\n  OBCISimulatorLineNoiseHz60: obciSimulatorLineNoiseHz60,\n  OBCISimulatorLineNoiseHz50: obciSimulatorLineNoiseHz50,\n  OBCISimulatorLineNoiseNone: obciSimulatorLineNoiseNone,\n  /** Possible Simulator Fragmentation modes */\n  OBCISimulatorFragmentationRandom: obciSimulatorFragmentationRandom,\n  OBCISimulatorFragmentationFullBuffers: obciSimulatorFragmentationFullBuffers,\n  OBCISimulatorFragmentationOneByOne: obciSimulatorFragmentationOneByOne,\n  OBCISimulatorFragmentationNone: obciSimulatorFragmentationNone,\n  /** Firmware version indicator */\n  OBCIFirmwareV1: obciFirmwareV1,\n  OBCIFirmwareV2: obciFirmwareV2,\n  OBCIFirmwareV3: obciFirmwareV3,\n  /** Time synced accel packet */\n  OBCIAccelAxisX: obciAccelAxisX,\n  OBCIAccelAxisY: obciAccelAxisY,\n  OBCIAccelAxisZ: obciAccelAxisZ,\n  /** Time from board */\n  OBCIStreamPacketTimeByteSize: obciStreamPacketTimeByteSize,\n  /** Parse */\n  OBCIParseDaisy: obciParseDaisy,\n  OBCIParseFailure: obciParseFailure,\n  OBCIParseFirmware: obciParseFirmware,\n  OBCIParseEOT: obciParseEOT,\n  OBCIParseSuccess: obciParseSuccess,\n  /** Used in parsing incoming serial data */\n  OBCIParsingChannelSettings: obciParsingChannelSettings,\n  OBCIParsingEOT: obciParsingEOT,\n  OBCIParsingNormal: obciParsingNormal,\n  OBCIParsingReset: obciParsingReset,\n  OBCIParsingTimeSyncSent: obciParsingTimeSyncSent,\n  /** Timeouts */\n  OBCITimeoutProcessBytes: obciTimeoutProcessBytes,\n  /** Simulator Board Configurations */\n  OBCISimulatorRawAux: obciSimulatorRawAux,\n  OBCISimulatorStandard: obciSimulatorStandard,\n  /** Radio Channel Limits */\n  OBCIRadioChannelMax: obciRadioChannelMax,\n  OBCIRadioChannelMin: obciRadioChannelMin,\n  OBCIRadioPollTimeMax: obciRadioPollTimeMax,\n  OBCIRadioPollTimeMin: obciRadioPollTimeMin,\n  /** Time sync stuff */\n  OBCITimeSyncArraySize: obciTimeSyncArraySize,\n  OBCITimeSyncMultiplierWithSyncConf: obciTimeSyncMultiplierWithSyncConf,\n  OBCITimeSyncMultiplierWithoutSyncConf: obciTimeSyncMultiplierWithoutSyncConf,\n  OBCITimeSyncThresholdTransFailureMS: obciTimeSyncThresholdTransFailureMS,\n  /** Set board mode */\n  OBCIBoardModeSet: obciBoardModeSet,\n  OBCIBoardModeCmdDefault: obciBoardModeCmdDefault,\n  OBCIBoardModeCmdDebug: obciBoardModeCmdDebug,\n  OBCIBoardModeCmdAnalog: obciBoardModeCmdAnalog,\n  OBCIBoardModeCmdDigital: obciBoardModeCmdDigital,\n  OBCIBoardModeCmdGetCur: obciBoardModeCmdGetCur,\n  OBCIBoardModeAnalog: obciBoardModeAnalog,\n  OBCIBoardModeDefault: obciBoardModeDefault,\n  OBCIBoardModeDebug: obciBoardModeDebug,\n  OBCIBoardModeDigital: obciBoardModeDigital,\n\n  /** Set sample rate */\n  OBCISampleRateSet: obciSampleRateSet,\n  OBCISampleRateCmdCyton16000: obciSampleRateCmdCyton16000,\n  OBCISampleRateCmdCyton8000: obciSampleRateCmdCyton8000,\n  OBCISampleRateCmdCyton4000: obciSampleRateCmdCyton4000,\n  OBCISampleRateCmdCyton2000: obciSampleRateCmdCyton2000,\n  OBCISampleRateCmdCyton1000: obciSampleRateCmdCyton1000,\n  OBCISampleRateCmdCyton500: obciSampleRateCmdCyton500,\n  OBCISampleRateCmdCyton250: obciSampleRateCmdCyton250,\n  OBCISampleRateCmdGang25600: obciSampleRateCmdGang25600,\n  OBCISampleRateCmdGang12800: obciSampleRateCmdGang12800,\n  OBCISampleRateCmdGang6400: obciSampleRateCmdGang6400,\n  OBCISampleRateCmdGang3200: obciSampleRateCmdGang3200,\n  OBCISampleRateCmdGang1600: obciSampleRateCmdGang1600,\n  OBCISampleRateCmdGang800: obciSampleRateCmdGang800,\n  OBCISampleRateCmdGang400: obciSampleRateCmdGang400,\n  OBCISampleRateCmdGang200: obciSampleRateCmdGang200,\n  OBCISampleRateCmdGetCur: obciSampleRateCmdaGetCur,\n\n  /** Wifi Stuff */\n  OBCIWifiAttach: obciWifiAttach,\n  OBCIWifiRemove: obciWifiRemove,\n  OBCIWifiReset: obciWifiReset,\n  OBCIWifiStatus: obciWifiStatus,\n  /** Baud Rates */\n  OBCIRadioBaudRateDefault: obciRadioBaudRateDefault,\n  OBCIRadioBaudRateDefaultStr: obciRadioBaudRateDefaultStr,\n  OBCIRadioBaudRateFast: obciRadioBaudRateFast,\n  OBCIRadioBaudRateFastStr: obciRadioBaudRateFastStr,\n  /** Emitters */\n  OBCIEmitterAccelerometer: obciEmitterAccelerometer,\n  OBCIEmitterBlePoweredUp: obciEmitterBlePoweredUp,\n  OBCIEmitterClose: obciEmitterClose,\n  OBCIEmitterDroppedPacket: obciEmitterDroppedPacket,\n  OBCIEmitterEot: obciEmitterEot,\n  OBCIEmitterError: obciEmitterError,\n  OBCIEmitterGanglionFound: obciEmitterGanglionFound,\n  OBCIEmitterHardSet: obciEmitterHardSet,\n  OBCIEmitterImpedance: obciEmitterImpedance,\n  OBCIEmitterImpedanceArray: obciEmitterImpedanceArray,\n  OBCIEmitterMessage: obciEmitterMessage,\n  OBCIEmitterQuery: obciEmitterQuery,\n  OBCIEmitterRawDataPacket: obciEmitterRawDataPacket,\n  OBCIEmitterReady: obciEmitterReady,\n  OBCIEmitterRFduino: obciEmitterRFduino,\n  OBCIEmitterSample: obciEmitterSample,\n  OBCIEmitterScanStopped: obciEmitterScanStopped,\n  OBCIEmitterSynced: obciEmitterSynced,\n  OBCIEmitterWifiShield: obciEmitterWifiShield,\n  /** Emitters */\n  /** Accel packets */\n  OBCIGanglionAccelAxisX: obciGanglionAccelAxisX,\n  OBCIGanglionAccelAxisY: obciGanglionAccelAxisY,\n  OBCIGanglionAccelAxisZ: obciGanglionAccelAxisZ,\n  /** Ganglion */\n  OBCIGanglionBleSearchTime: obciGanglionBleSearchTime,\n  OBCIGanglionByteIdUncompressed: obciGanglionByteIdUncompressed,\n  OBCIGanglionByteId18Bit: obciGanglionByteId18Bit,\n  OBCIGanglionByteId19Bit: obciGanglionByteId19Bit,\n  OBCIGanglionByteIdImpedanceChannel1: obciGanglionByteIdImpedanceChannel1,\n  OBCIGanglionByteIdImpedanceChannel2: obciGanglionByteIdImpedanceChannel2,\n  OBCIGanglionByteIdImpedanceChannel3: obciGanglionByteIdImpedanceChannel3,\n  OBCIGanglionByteIdImpedanceChannel4: obciGanglionByteIdImpedanceChannel4,\n  OBCIGanglionByteIdImpedanceChannelReference: obciGanglionByteIdImpedanceChannelReference,\n  OBCIGanglionByteIdMultiPacket: obciGanglionByteIdMultiPacket,\n  OBCIGanglionByteIdMultiPacketStop: obciGanglionByteIdMultiPacketStop,\n  OBCIGanglionMCP3912Gain: obciGanglionMCP3912Gain, // assumed gain setting for MCP3912.  NEEDS TO BE ADJUSTABLE JM\n  OBCIGanglionMCP3912Vref: obciGanglionMCP3912Vref, // reference voltage for ADC in MCP3912 set in hardware\n  OBCIGanglionPacketSize: obciGanglionPacketSize,\n  OBCIGanglionPacket18Bit: obciGanglionPacket18Bit,\n  OBCIGanglionPacket19Bit: obciGanglionPacket19Bit,\n  OBCIGanglionPrefix: obciGanglionPrefix,\n  OBCIGanglionSamplesPerPacket: obciGanglionSamplesPerPacket,\n  OBCIGanglionSyntheticDataEnable: obciGanglionSyntheticDataEnable,\n  OBCIGanglionSyntheticDataDisable: obciGanglionSyntheticDataDisable,\n  OBCIGanglionImpedanceStart: obciGanglionImpedanceStart,\n  OBCIGanglionImpedanceStop: obciGanglionImpedanceStop,\n  OBCIGanglionScaleFactorPerCountVolts: obciGanglionScaleFactorPerCountVolts,\n  /** Simblee */\n  SimbleeUuidService: simbleeUuidService,\n  SimbleeUuidReceive: simbleeUuidReceive,\n  SimbleeUuidSend: simbleeUuidSend,\n  SimbleeUuidDisconnect: simbleeUuidDisconnect,\n  /** RFduino BLE UUID */\n  RFduinoUuidService: rfduinoUuidService,\n  RFduinoUuidReceive: rfduinoUuidReceive,\n  RFduinoUuidSend: rfduinoUuidSend,\n  RFduinoUuidSendTwo: rfduinoUuidSendTwo,\n  /** Cyton BLE */\n  OBCICytonBLESamplesPerPacket: obciCytonBLESamplesPerPacket,\n  /** Accel scale factor */\n  OBCIGanglionAccelScaleFactor: obciGanglionAccelScaleFactor,\n  /** Noble */\n  OBCINobleEmitterPeripheralConnect: obciNobleEmitterPeripheralConnect,\n  OBCINobleEmitterPeripheralDisconnect: obciNobleEmitterPeripheralDisconnect,\n  OBCINobleEmitterPeripheralDiscover: obciNobleEmitterPeripheralDiscover,\n  OBCINobleEmitterPeripheralServicesDiscover: obciNobleEmitterPeripheralServicesDiscover,\n  OBCINobleEmitterServiceCharacteristicsDiscover: obciNobleEmitterServiceCharacteristicsDiscover,\n  OBCINobleEmitterServiceRead: obciNobleEmitterServiceRead,\n  OBCINobleEmitterDiscover: obciNobleEmitterDiscover,\n  OBCINobleEmitterScanStart: obciNobleEmitterScanStart,\n  OBCINobleEmitterScanStop: obciNobleEmitterScanStop,\n  OBCINobleEmitterStateChange: obciNobleEmitterStateChange,\n  OBCINobleStatePoweredOn: obciNobleStatePoweredOn,\n  getPeripheralLocalNames,\n  getPeripheralWithLocalName,\n  getVersionNumber,\n  isPeripheralGanglion,\n  commandSampleRateForCmdCyton,\n  commandSampleRateForCmdGanglion,\n  commandBoardModeForMode,\n  rawDataToSampleObjectDefault,\n  /** Protocols */\n  OBCIProtocolBLE: obciProtocolBLE,\n  OBCIProtocolSerial: obciProtocolSerial,\n  OBCIProtocolWifi: obciProtocolWifi,\n  /** Register Query for Cyton */\n  OBCIRegisterQueryAccelerometerFirmwareV1: obciRegisterQueryAccelerometerFirmwareV1,\n  OBCIRegisterQueryAccelerometerFirmwareV3: obciRegisterQueryAccelerometerFirmwareV3,\n  OBCIRegisterQueryCyton: obciRegisterQueryCyton,\n  OBCIRegisterQueryCytonDaisy: obciRegisterQueryCytonDaisy,\n  OBCIRegisterQueryNameMISC1: obciRegisterQueryNameMISC1,\n  OBCIRegisterQueryNameBIASSENSP: obciRegisterQueryNameBIASSENSP,\n  OBCIRegisterQueryNameCHnSET: obciRegisterQueryNameCHnSET,\n  OBCIRegisterQuerySizeCytonFirmwareV1: obciRegisterQuerySizeCytonFirmwareV1,\n  OBCIRegisterQuerySizeCytonDaisyFirmwareV1: obciRegisterQuerySizeCytonDaisyFirmwareV1,\n  OBCIRegisterQuerySizeCytonFirmwareV3: obciRegisterQuerySizeCytonFirmwareV3,\n  OBCIRegisterQuerySizeCytonDaisyFirmwareV3: obciRegisterQuerySizeCytonDaisyFirmwareV3\n};\n\n/**\r\n* @description To add a usability abstraction layer above channel setting commands. Due to the\r\n*          extensive and highly specific nature of the channel setting command chain, this\r\n*          will take several different human readable inputs and merge to one array filled\r\n*          with the correct commands, prime for sending directly to the write command.\r\n* @param channelNumber - Number (1-16)\r\n* @param powerDown - Bool (true -> OFF, false -> ON (default))\r\n*          turns the channel on or off\r\n* @param gain - Number (1,2,4,6,8,12,24(default))\r\n*          sets the gain for the channel\r\n* @param inputType - String (normal,shorted,biasMethod,mvdd,temp,testsig,biasDrp,biasDrn)\r\n*          selects the ADC channel input source\r\n* @param bias - Bool (true -> Include in bias (default), false -> remove from bias)\r\n*          selects to include the channel input in bias generation\r\n* @param srb2 - Bool (true -> Connect this input to SRB2 (default),\r\n*                     false -> Disconnect this input from SRB2)\r\n*          Select to connect (true) this channel's P input to the SRB2 pin. This closes\r\n*              a switch between P input and SRB2 for the given channel, and allows the\r\n*              P input to also remain connected to the ADC.\r\n* @param srb1 - Bool (true -> connect all N inputs to SRB1,\r\n*                     false -> Disconnect all N inputs from SRB1 (default))\r\n*          Select to connect (true) all channels' N inputs to SRB1. This effects all pins,\r\n*              and disconnects all N inputs from the ADC.\r\n* @returns {Promise} resolves {commandArray: array of commands to be sent,\r\n                               newChannelSettingsObject: an updated channel settings object\r\n                                                         to be stored in openBCIBoard.channelSettingsArray},\r\n                     rejects on bad input or no board\r\n*/\nfunction channelSetter(channelNumber, powerDown, gain, inputType, bias, srb2, srb1) {\n  // Used to store and assemble the commands\n  var cmdPowerDown, cmdBias, cmdSrb2, cmdSrb1;\n\n  return new Promise(function (resolve, reject) {\n    // Validate the input\n    if (!isNumber(channelNumber)) reject(Error(\"channelNumber must be of type 'number' \"));\n    if (!isBoolean(powerDown)) reject(Error(\"powerDown must be of type 'boolean' \"));\n    if (!isNumber(gain)) reject(Error(\"gain must be of type 'number' \"));\n    if (!isString(inputType)) reject(Error(\"inputType must be of type 'string' \"));\n    if (!isBoolean(bias)) reject(Error(\"bias must be of type 'boolean' \"));\n    if (!isBoolean(srb2)) reject(Error(\"srb1 must be of type 'boolean' \"));\n    if (!isBoolean(srb1)) reject(Error(\"srb2 must be of type 'boolean' \"));\n\n    // Set Channel Number\n    var p1 = commandChannelForCmd(channelNumber).catch(err => reject(err));\n\n    // Set POWER_DOWN\n    cmdPowerDown = powerDown ? obciChannelCmdPowerOff : obciChannelCmdPowerOn;\n\n    // Set Gain\n    var p2 = commandForGain(gain).catch(err => reject(err));\n\n    // Set ADC string\n    var p3 = commandForADCString(inputType).catch(err => reject(err));\n\n    // Set BIAS\n    cmdBias = bias ? obciChannelCmdBiasInclude : obciChannelCmdBiasRemove;\n\n    // Set SRB2\n    cmdSrb2 = srb2 ? obciChannelCmdSRB2Connect : obciChannelCmdSRB2Diconnect;\n\n    // Set SRB1\n    cmdSrb1 = srb1 ? obciChannelCmdSRB1Connect : obciChannelCmdSRB1Diconnect;\n\n    var newChannelSettingsObject = {\n      channelNumber: channelNumber,\n      powerDown: powerDown,\n      gain: gain,\n      inputType: inputType,\n      bias: bias,\n      srb2: srb2,\n      srb1: srb1\n    };\n\n    Promise.all([p1, p2, p3]).then(function (values) {\n      var outputArray = [obciChannelCmdSet, values[0], cmdPowerDown, values[1], values[2], cmdBias, cmdSrb2, cmdSrb1, obciChannelCmdLatch];\n      resolve({ commandArray: outputArray, newChannelSettingsObject: newChannelSettingsObject });\n    });\n  });\n}\n\n/**\r\n* @description To build the array of commands to send to the board to measure impedance\r\n* @param channelNumber\r\n* @param pInputApplied - Bool (true -> Test Signal Applied, false -> Test Signal Not Applied (default))\r\n*          applies the test signal to the P input\r\n* @param nInputApplied - Bool (true -> Test Signal Applied, false -> Test Signal Not Applied (default))\r\n*          applies the test signal to the N input\r\n* @returns {Promise} - fulfilled will contain an array of comamnds\r\n*/\nfunction impedanceSetter(channelNumber, pInputApplied, nInputApplied) {\n  var cmdNInputApplied, cmdPInputApplied;\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isNumber(channelNumber)) reject(Error(\"channelNumber must be of type 'number' \"));\n    if (!isBoolean(pInputApplied)) reject(Error(\"pInputApplied must be of type 'boolean' \"));\n    if (!isBoolean(nInputApplied)) reject(Error(\"nInputApplied must be of type 'boolean' \"));\n\n    // Set pInputApplied\n    cmdPInputApplied = pInputApplied ? obciChannelImpedanceTestSignalApplied : obciChannelImpedanceTestSignalAppliedNot;\n\n    // Set nInputApplied\n    cmdNInputApplied = nInputApplied ? obciChannelImpedanceTestSignalApplied : obciChannelImpedanceTestSignalAppliedNot;\n\n    // Set Channel Number\n    commandChannelForCmd(channelNumber).then(command => {\n      var outputArray = [obciChannelImpedanceSet, command, cmdPInputApplied, cmdNInputApplied, obciChannelImpedanceLatch];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\n/**\r\n * @description To build the array of commands to send to the board to set the sample rate\r\n * @param boardType {String} - The type of board, either cyton or ganglion. Default is Cyton\r\n * @param sampleRate {Number} - The sample rate you want to set to. Please see docs for possible sample rates.\r\n * @returns {Promise} - fulfilled will contain an array of commands\r\n */\nfunction sampleRateSetter(boardType, sampleRate) {\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isString(boardType)) return reject(Error(\"board type must be of type 'string' \"));\n\n    if (!isNumber(sampleRate)) return reject(Error(\"sampleRate must be of type 'number' \"));\n\n    sampleRate = Math.floor(sampleRate);\n\n    let func;\n    if (boardType === obciBoardCyton || boardType === obciBoardDaisy) {\n      func = commandSampleRateForCmdCyton;\n    } else if (boardType === obciBoardGanglion) {\n      func = commandSampleRateForCmdGanglion;\n    } else {\n      return reject(Error(`boardType must be either ${obciBoardCyton} or ${obciBoardGanglion}`));\n    }\n\n    // Set Channel Number\n    func(sampleRate).then(command => {\n      var outputArray = [obciSampleRateSet, command];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\n/**\r\n * @description To build the array of commands to send to the board t\r\n * @param boardMode {String} - The type of board mode:\r\n *  `default`: Board will use Accel\r\n *  `\r\n * @returns {Promise} - fulfilled will contain an array of commands\r\n */\nfunction boardModeSetter(boardMode) {\n  return new Promise((resolve, reject) => {\n    // validate inputs\n    if (!isString(boardMode)) return reject(Error(\"board mode must be of type 'string' \"));\n    // Set Channel Number\n    commandBoardModeForMode(boardMode).then(command => {\n      var outputArray = [obciBoardModeSet, command];\n      // console.log(outputArray)\n      resolve(outputArray);\n    }).catch(err => reject(err));\n  });\n}\n\nfunction isNumber(input) {\n  return typeof input === 'number';\n}\nfunction isBoolean(input) {\n  return typeof input === 'boolean';\n}\nfunction isString(input) {\n  return typeof input === 'string';\n}\nfunction isUndefined(input) {\n  return typeof input === 'undefined';\n}\nfunction isNull(input) {\n  return input === null;\n}\n\nfunction commandForADCString(adcString) {\n  return new Promise(function (resolve, reject) {\n    switch (adcString) {\n      case obciStringADCNormal:\n        resolve(obciChannelCmdADCNormal);\n        break;\n      case obciStringADCShorted:\n        resolve(obciChannelCmdADCShorted);\n        break;\n      case obciStringADCBiasMethod:\n        resolve(obciChannelCmdADCBiasMethod);\n        break;\n      case obciStringADCMvdd:\n        resolve(obciChannelCmdADCMVDD);\n        break;\n      case obciStringADCTemp:\n        resolve(obciChannelCmdADCTemp);\n        break;\n      case obciStringADCTestSig:\n        resolve(obciChannelCmdADCTestSig);\n        break;\n      case obciStringADCBiasDrp:\n        resolve(obciChannelCmdADCBiasDRP);\n        break;\n      case obciStringADCBiasDrn:\n        resolve(obciChannelCmdADCBiasDRN);\n        break;\n      default:\n        reject(Error('Invalid ADC string'));\n        break;\n    }\n  });\n}\n\n/**\r\n * Returns the input type for the given command\r\n * @param cmd {Number} The command\r\n * @returns {String}\r\n */\nfunction inputTypeForCommand(cmd) {\n  switch (String(cmd)) {\n    case obciChannelCmdADCNormal:\n      return obciStringADCNormal;\n    case obciChannelCmdADCShorted:\n      return obciStringADCShorted;\n    case obciChannelCmdADCBiasMethod:\n      return obciStringADCBiasMethod;\n    case obciChannelCmdADCMVDD:\n      return obciStringADCMvdd;\n    case obciChannelCmdADCTemp:\n      return obciStringADCTemp;\n    case obciChannelCmdADCTestSig:\n      return obciStringADCTestSig;\n    case obciChannelCmdADCBiasDRP:\n      return obciStringADCBiasDrp;\n    case obciChannelCmdADCBiasDRN:\n      return obciStringADCBiasDrn;\n    default:\n      throw new Error('Invalid input type, must be less than 8');\n  }\n}\n\nfunction commandForGain(gainSetting) {\n  return new Promise(function (resolve, reject) {\n    switch (gainSetting) {\n      case 1:\n        resolve(obciChannelCmdGain1);\n        break;\n      case 2:\n        resolve(obciChannelCmdGain2);\n        break;\n      case 4:\n        resolve(obciChannelCmdGain4);\n        break;\n      case 6:\n        resolve(obciChannelCmdGain6);\n        break;\n      case 8:\n        resolve(obciChannelCmdGain8);\n        break;\n      case 12:\n        resolve(obciChannelCmdGain12);\n        break;\n      case 24:\n        resolve(obciChannelCmdGain24);\n        break;\n      default:\n        reject(Error('Invalid gain setting of ' + gainSetting + ' gain must be (1,2,4,6,8,12,24)'));\n        break;\n    }\n  });\n}\n\n/**\r\n * Get the gain\r\n * @param cmd {Number}\r\n * @returns {Number}\r\n */\nfunction gainForCommand(cmd) {\n  switch (String(cmd)) {\n    case obciChannelCmdGain1:\n      return 1;\n    case obciChannelCmdGain2:\n      return 2;\n    case obciChannelCmdGain4:\n      return 4;\n    case obciChannelCmdGain6:\n      return 6;\n    case obciChannelCmdGain8:\n      return 8;\n    case obciChannelCmdGain12:\n      return 12;\n    case obciChannelCmdGain24:\n      return 24;\n    default:\n      throw new Error(`Invalid gain setting of ${cmd} gain must be (0,1,2,3,4,5,6)`);\n  }\n}\n\nfunction commandChannelForCmd(channelNumber) {\n  return new Promise(function (resolve, reject) {\n    switch (channelNumber) {\n      case 1:\n        resolve(obciChannelCmdChannel1);\n        break;\n      case 2:\n        resolve(obciChannelCmdChannel2);\n        break;\n      case 3:\n        resolve(obciChannelCmdChannel3);\n        break;\n      case 4:\n        resolve(obciChannelCmdChannel4);\n        break;\n      case 5:\n        resolve(obciChannelCmdChannel5);\n        break;\n      case 6:\n        resolve(obciChannelCmdChannel6);\n        break;\n      case 7:\n        resolve(obciChannelCmdChannel7);\n        break;\n      case 8:\n        resolve(obciChannelCmdChannel8);\n        break;\n      case 9:\n        resolve(obciChannelCmdChannel9);\n        break;\n      case 10:\n        resolve(obciChannelCmdChannel10);\n        break;\n      case 11:\n        resolve(obciChannelCmdChannel11);\n        break;\n      case 12:\n        resolve(obciChannelCmdChannel12);\n        break;\n      case 13:\n        resolve(obciChannelCmdChannel13);\n        break;\n      case 14:\n        resolve(obciChannelCmdChannel14);\n        break;\n      case 15:\n        resolve(obciChannelCmdChannel15);\n        break;\n      case 16:\n        resolve(obciChannelCmdChannel16);\n        break;\n      default:\n        reject(Error('Invalid channel number'));\n        break;\n    }\n  });\n}\n\n/**\r\n * @typedef {Object} ChannelSettingsObject - See page 50 of the ads1299.pdf\r\n * @property {Number} channelNumber - The channel number of this object\r\n * @property {Boolean} powerDown - Power-down: - This boolean determines the channel power mode for the\r\n *                      corresponding channel. `false` for normal operation, channel is on, and `true` for channel\r\n *                      power-down, channel is off. (Default is `false`)\r\n * @property {Number} gain - PGA gain: This number determines the PGA gain setting. Can be either 1, 2, 4, 6, 8, 12, 24\r\n *                      (Default is 24)\r\n * @property {String} inputType - Channel input: This string is used to determine the channel input selection.\r\n *                      Can be:\r\n *                        'normal' - Normal electrode input (Default)\r\n *                        'shorted' - Input shorted (for offset or noise measurements)\r\n *                        'biasMethod' - Used in conjunction with BIAS_MEAS bit for BIAS measurements.\r\n *                        'mvdd' - MVDD for supply measurement\r\n *                        'temp' - Temperature sensor\r\n *                        'testsig' - Test signal\r\n *                        'biasDrp' - BIAS_DRP (positive electrode is the driver)\r\n *                        'biasDrn' - BIAS_DRN (negative electrode is the driver)\r\n * @property {Boolean} bias - BIAS: Is the channel included in the bias? If `true` or yes, this channel has both P\r\n *                      and N channels connected to the bias. (Default is `true`)\r\n * @property {Boolean} srb2 - SRB2 connection: This boolean determines the SRB2 connection for the corresponding\r\n *                      channel. `false` for open, not connected to channel, and `true` for closed, connected to the\r\n *                      channel. (Default is `true`)\r\n * @property {Boolean} srb1 - Stimulus, reference, and bias 1: This boolean connects the SRB2 to all 4, 6, or 8\r\n *                      channels inverting inputs. `false` when switches open, disconnected, and `true` when switches\r\n *                      closed, or connected. (Default is `false`)\r\n */\n\n/**\r\n * Get an object of default board settings.\r\n * @param channelNumber\r\n * @returns {ChannelSettingsObject}\r\n */\nfunction channelSettingsObjectDefault(channelNumber) {\n  return {\n    channelNumber: channelNumber,\n    powerDown: false,\n    gain: 24,\n    inputType: obciStringADCNormal,\n    bias: true,\n    srb2: true,\n    srb1: false\n  };\n}\n\n/**\r\n * @description RawDataToSample default object creation\r\n * @param numChannels {Number} - The number of channels\r\n * @returns {RawDataToSample} - A new object\r\n */\nfunction rawDataToSampleObjectDefault(numChannels) {\n  if (numChannels === undefined) numChannels = obciNumberOfChannelsDefault;\n  return {\n    accelArray: [0, 0, 0],\n    channelSettings: constantsModule.channelSettingsArrayInit(numChannels),\n    decompressedSamples: decompressedSamplesInit(numChannels),\n    lastSampleNumber: 0,\n    rawDataPacket: __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"].alloc(33),\n    rawDataPackets: [],\n    scale: true,\n    sendCounts: false,\n    timeOffset: 0,\n    verbose: false\n  };\n}\n\nfunction decompressedSamplesInit(numChannels) {\n  let output = [];\n  for (let i = 0; i < 3; i++) {\n    output.push(new Array(numChannels));\n  }\n  return output;\n}\n\n/**\r\n * Get's the command for sample rate Cyton\r\n * @param sampleRate {Number} - The desired sample rate\r\n * @return {Promise}\r\n */\nfunction commandSampleRateForCmdCyton(sampleRate) {\n  return new Promise(function (resolve, reject) {\n    switch (sampleRate) {\n      case obciSampleRate16000:\n        resolve(obciSampleRateCmdCyton16000);\n        break;\n      case obciSampleRate8000:\n        resolve(obciSampleRateCmdCyton8000);\n        break;\n      case obciSampleRate4000:\n        resolve(obciSampleRateCmdCyton4000);\n        break;\n      case obciSampleRate2000:\n        resolve(obciSampleRateCmdCyton2000);\n        break;\n      case obciSampleRate1000:\n        resolve(obciSampleRateCmdCyton1000);\n        break;\n      case obciSampleRate500:\n        resolve(obciSampleRateCmdCyton500);\n        break;\n      case obciSampleRate250:\n        resolve(obciSampleRateCmdCyton250);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\r\n * Get's the command for sample rate Cyton\r\n * @param sampleRate {Number} - The desired sample rate\r\n * @return {Promise}\r\n */\nfunction commandSampleRateForCmdGanglion(sampleRate) {\n  return new Promise(function (resolve, reject) {\n    switch (sampleRate) {\n      case obciSampleRate25600:\n        resolve(obciSampleRateCmdGang25600);\n        break;\n      case obciSampleRate12800:\n        resolve(obciSampleRateCmdGang12800);\n        break;\n      case obciSampleRate6400:\n        resolve(obciSampleRateCmdGang6400);\n        break;\n      case obciSampleRate3200:\n        resolve(obciSampleRateCmdGang3200);\n        break;\n      case obciSampleRate1600:\n        resolve(obciSampleRateCmdGang1600);\n        break;\n      case obciSampleRate800:\n        resolve(obciSampleRateCmdGang800);\n        break;\n      case obciSampleRate400:\n        resolve(obciSampleRateCmdGang400);\n        break;\n      case obciSampleRate200:\n        resolve(obciSampleRateCmdGang200);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\r\n * Get's the command for sample rate Cyton\r\n * @param boardMode {String} - The desired sample rate\r\n * @return {Promise}\r\n */\nfunction commandBoardModeForMode(boardMode) {\n  return new Promise(function (resolve, reject) {\n    switch (boardMode) {\n      case obciBoardModeDefault:\n        resolve(obciBoardModeCmdDefault);\n        break;\n      case obciBoardModeDebug:\n        resolve(obciBoardModeCmdDebug);\n        break;\n      case obciBoardModeAnalog:\n        resolve(obciBoardModeCmdAnalog);\n        break;\n      case obciBoardModeDigital:\n        resolve(obciBoardModeCmdDigital);\n        break;\n      default:\n        reject(Error('Invalid sample rate'));\n        break;\n    }\n  });\n}\n\n/**\r\n * @description Get a list of local names from an array of peripherals\r\n */\nfunction getPeripheralLocalNames(pArray) {\n  return new Promise((resolve, reject) => {\n    var list = [];\n    pArray.forEach(perif => {\n      list.push(perif.advertisement.localName);\n    });\n    if (list.length > 0) {\n      return resolve(list);\n    } else {\n      return reject(Error(`No peripherals discovered with prefix equal to ${obciGanglionPrefix}`));\n    }\n  });\n}\n\n/**\r\n * @description Get a peripheral with a local name\r\n * @param `pArray` {Array} - Array of peripherals\r\n * @param `localName` {String} - The local name of the BLE device.\r\n */\nfunction getPeripheralWithLocalName(pArray, localName) {\n  return new Promise((resolve, reject) => {\n    if (typeof pArray !== 'object') return reject(Error(`pArray must be of type Object`));\n    pArray.forEach(perif => {\n      if (perif.advertisement.hasOwnProperty('localName')) {\n        if (perif.advertisement.localName === localName) {\n          return resolve(perif);\n        }\n      }\n    });\n    return reject(Error(`No peripheral found with localName: ${localName}`));\n  });\n}\n\n/**\r\n * @description This function is used to extract the major version from a github\r\n *  version string.\r\n * @returns {Number} The major version number\r\n */\nfunction getVersionNumber(versionStr) {\n  return Number(versionStr[1]);\n}\n\n/**\r\n * @description Very safely checks to see if the noble peripheral is a\r\n *  ganglion by way of checking the local name property.\r\n */\nfunction isPeripheralGanglion(peripheral) {\n  if (peripheral) {\n    if (peripheral.hasOwnProperty('advertisement')) {\n      if (peripheral.advertisement !== null && peripheral.advertisement.hasOwnProperty('localName')) {\n        if (peripheral.advertisement.localName !== undefined && peripheral.advertisement.localName !== null) {\n          if (peripheral.advertisement.localName.indexOf(obciGanglionPrefix) > -1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (constantsModule);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants.js\n// module id = 5\n// module chunks = 0 1 3\n\n//# sourceURL=webpack:///./src/constants.js?");

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"default\"] = debugBytes;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer___);\n\n\n\n/**\r\n * @description Output passed bytes on the console as a hexdump, if enabled\r\n * @param prefix - label to show to the left of bytes\r\n * @param data - bytes to output, a buffer or string\r\n * @private\r\n */\nfunction debugBytes(prefix, data) {\n  if (typeof data === 'string') data = new __WEBPACK_IMPORTED_MODULE_0_buffer___[\"Buffer\"](data);\n\n  console.log('Debug bytes:');\n\n  for (var j = 0; j < data.length;) {\n    var hexPart = '';\n    var ascPart = '';\n    for (var end = Math.min(data.length, j + 16); j < end; ++j) {\n      var byt = data[j];\n\n      var hex = ('0' + byt.toString(16)).slice(-2);\n      hexPart += (j & 0xf) === 0x8 ? '  ' : ' '; // puts an extra space 8 bytes in\n      hexPart += hex;\n\n      var asc = byt >= 0x20 && byt < 0x7f ? String.fromCharCode(byt) : '.';\n      ascPart += asc;\n    }\n\n    // pad to fixed width for alignment\n    hexPart = (hexPart + '                                                   ').substring(0, 3 * 17);\n\n    console.log(prefix + ' ' + hexPart + '|' + ascPart + '|');\n  }\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/debug.js\n// module id = 6\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/debug.js?");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gaussian__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gaussian___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gaussian__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_streamsearch__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_streamsearch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_streamsearch__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_buffer___ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_buffer____default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_buffer___);\n\n\n\n\n\n\n\n/** Constants for interpreting the EEG data */\n// Reference voltage for ADC in ADS1299.\n//   Set by its hardware.\nconst ADS1299_VREF = 4.5;\n// Scale factor for aux data\nconst SCALE_FACTOR_ACCEL = 0.002 / Math.pow(2, 4);\n// X, Y, Z\nconst ACCEL_NUMBER_AXIS = 3;\n// Default ADS1299 gains array\n\nlet utilitiesModule = {\n\n  /**\r\n   * @typedef {Object} ProcessedBuffer\r\n   * @property {Buffer|SafeBuffer|Buffer2} buffer The remaining buffer. Can be null.\r\n   * @property {Array} rawDataPackets The extracted raw data packets\r\n   */\n  /**\r\n   * @typedef {Object} Sample\r\n   * @property {Array} accelData of floats of accel data. not always present in object.\r\n   * @property {Number} sampleNumber The sample number\r\n   * @property {Array} channelData The extracted channel data\r\n   * @property {Buffer} rawDataPacket The raw data packet\r\n   * @property {Boolean} valid If the sample is valid\r\n   */\n  /**\r\n   * @typedef {Object} Impedance\r\n   * @property {Number} channelNumber The channel number\r\n   * @property {Number} impedanceValue The impedance in ohms\r\n   */\n  /**\r\n   * @typedef {Object} RawDataToSample\r\n   * @property {Array} rawDataPackets - An array of rawDataPackets\r\n   * @property {Buffer} rawDataPacket - A single raw data packet\r\n   * @property {Buffer} multiPacketBuffer - This buffer is used to build up multiple messages over ble and emit them at once\r\n   * @property {Array} channelSettings - The channel settings array\r\n   * @property {Number} timeOffset (optional) for non time stamp use cases i.e. 0xC0 or 0xC1 (default and raw aux)\r\n   * @property {Array} accelArray (optional) for non time stamp use cases\r\n   * @property {Boolean} verbose (optional) for verbose output\r\n   * @property {Number} lastSampleNumber (optional) - The last sample number\r\n   * @property {Boolean} scale (optional) Default `true`. A gain of 24 for Cyton will be used and 51 for ganglion by default.\r\n   * @property {Array} decompressedSamples - An array to hold delta compression items\r\n   * @property {Boolean} sendCounts - True if you want raw A/D counts or scaled counts in samples\r\n   */\n\n  /**\r\n   * @description Used to extract samples out of a buffer of unknown length\r\n   * @param dataBuffer {Buffer} - A buffer to parse for samples\r\n   * @returns {ProcessedBuffer} - Object with parsed raw packets and remaining buffer. Calling function shall maintain\r\n   *  the buffer in it's scope.\r\n   * @author AJ Keller (@aj-ptw)\r\n   */\n  extractRawDataPackets: dataBuffer => {\n    if (!dataBuffer) {\n      return {\n        'buffer': dataBuffer,\n        'rawDataPackets': []\n      };\n    }\n    let bytesToParse = dataBuffer.length;\n    let rawDataPackets = [];\n    // Exit if we have a buffer with less data than a packet\n    if (bytesToParse < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) {\n      return {\n        'buffer': dataBuffer,\n        'rawDataPackets': rawDataPackets\n      };\n    }\n\n    let parsePosition = 0;\n    // Begin parseing\n    while (parsePosition <= bytesToParse - __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) {\n      // Is the current byte a head byte that looks like 0xA0\n      if (dataBuffer[parsePosition] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) {\n        // Now that we know the first is a head byte, let's see if the last one is a\n        //  tail byte 0xCx where x is the set of numbers from 0-F (hex)\n        if (isStopByte(dataBuffer[parsePosition + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1])) {\n          // console.log(dataBuffer[parsePosition+1]);\n          /** We just qualified a raw packet */\n          // This could be a time set packet!\n          // this.timeOfPacketArrival = this.time();\n          // Grab the raw packet, make a copy of it.\n          let rawPacket;\n          rawPacket = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuffer.slice(parsePosition, parsePosition + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize));\n\n          // Emit that buffer\n          // this.emit('rawDataPacket', rawPacket);\n          rawDataPackets.push(rawPacket);\n          // Submit the packet for processing\n          // this._processQualifiedPacket(rawPacket);\n          // Overwrite the dataBuffer with a new buffer\n          let tempBuf;\n          if (parsePosition > 0) {\n            tempBuf = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].concat([__WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuffer.slice(0, parsePosition)), __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuffer.slice(parsePosition + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize))]);\n          } else {\n            tempBuf = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuffer.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize));\n          }\n          if (tempBuf.length === 0) {\n            dataBuffer = null;\n          } else {\n            dataBuffer = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(tempBuf);\n          }\n          // Move the parse position up one packet\n          parsePosition = -1;\n          bytesToParse -= __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize;\n        }\n      }\n      parsePosition++;\n    }\n    return {\n      'buffer': dataBuffer,\n      'rawDataPackets': rawDataPackets\n    };\n  },\n  extractRawBLEDataPackets: dataBuffer => {\n    let rawDataPackets = [];\n    if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(dataBuffer)) return rawDataPackets;\n    // Verify the packet is of length 20\n    if (dataBuffer.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSizeBLECyton) return rawDataPackets;\n    let sampleNumbers = [0, 0, 0];\n    sampleNumbers[0] = dataBuffer[1];\n    sampleNumbers[1] = sampleNumbers[0] + 1;\n    if (sampleNumbers[1] > 255) sampleNumbers[1] -= 256;\n    sampleNumbers[2] = sampleNumbers[1] + 1;\n    if (sampleNumbers[2] > 255) sampleNumbers[2] -= 256;\n    for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCICytonBLESamplesPerPacket; i++) {\n      let rawDataPacket = utilitiesModule.samplePacketZero(sampleNumbers[i]);\n      rawDataPacket[0] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n      rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte] = dataBuffer[0];\n      dataBuffer.copy(rawDataPacket, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart + i * 6, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart + 6 + i * 6);\n      rawDataPackets.push(rawDataPacket);\n    }\n    return rawDataPackets;\n  },\n  transformRawDataPacketToSample,\n  transformRawDataPacketsToSample,\n  convertGanglionArrayToBuffer,\n  getRawPacketType,\n  getFromTimePacketAccel,\n  getFromTimePacketTime,\n  getFromTimePacketRawAux,\n  ganglionFillRawDataPacket,\n  parsePacketStandardAccel,\n  parsePacketStandardRawAux,\n  parsePacketTimeSyncedAccel,\n  parsePacketTimeSyncedRawAux,\n  parsePacketImpedance,\n  /**\r\n  * @description Mainly used by the simulator to convert a randomly generated sample into a std OpenBCI V3 Packet\r\n  * @param sample - A sample object\r\n  * @returns {Buffer}\r\n  */\n  convertSampleToPacketStandard: sample => {\n    let packetBuffer = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize);\n    packetBuffer.fill(0);\n\n    // start byte\n    packetBuffer[0] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n\n    // sample number\n    packetBuffer[1] = sample.sampleNumber;\n\n    // channel data\n    for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault; i++) {\n      let threeByteBuffer = floatTo3ByteBuffer(sample.channelData[i]);\n\n      threeByteBuffer.copy(packetBuffer, 2 + i * 3);\n    }\n\n    for (let j = 0; j < 3; j++) {\n      let twoByteBuffer = floatTo2ByteBuffer(sample.auxData[j]);\n\n      twoByteBuffer.copy(packetBuffer, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1 - 6 + j * 2);\n    }\n\n    // stop byte\n    packetBuffer[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStop;\n\n    return packetBuffer;\n  },\n  /**\r\n  * @description Mainly used by the simulator to convert a randomly generated sample into a std OpenBCI V3 Packet\r\n  * @param sample - A sample object\r\n  * @param rawAux {Buffer} - A 6 byte long buffer to insert into raw buffer\r\n  * @returns {Buffer} - A 33 byte long buffer\r\n  */\n  convertSampleToPacketRawAux: (sample, rawAux) => {\n    let packetBuffer = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize);\n    packetBuffer.fill(0);\n\n    // start byte\n    packetBuffer[0] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n\n    // sample number\n    packetBuffer[1] = sample.sampleNumber;\n\n    // channel data\n    for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault; i++) {\n      let threeByteBuffer = floatTo3ByteBuffer(sample.channelData[i]);\n\n      threeByteBuffer.copy(packetBuffer, 2 + i * 3);\n    }\n\n    // Write the raw aux bytes\n    rawAux.copy(packetBuffer, 26);\n\n    // stop byte\n    packetBuffer[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1] = makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardRawAux);\n\n    return packetBuffer;\n  },\n  /**\r\n  * @description Mainly used by the simulator to convert a randomly generated sample into an accel time sync set buffer\r\n  * @param sample {Buffer} - A sample object\r\n  * @param time {Number} - The time to inject into the sample.\r\n  * @returns {Buffer} - A time sync accel packet\r\n  */\n  convertSampleToPacketAccelTimeSyncSet: (sample, time) => {\n    let buf = convertSampleToPacketAccelTimeSynced(sample, time);\n    buf[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte] = makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSyncSet);\n    return buf;\n  },\n  /**\r\n  * @description Mainly used by the simulator to convert a randomly generated sample into an accel time synced buffer\r\n  * @param sample {Buffer} - A sample object\r\n  * @param time {Number} - The time to inject into the sample.\r\n  * @returns {Buffer} - A time sync accel packet\r\n  */\n  convertSampleToPacketAccelTimeSynced,\n  /**\r\n  * @description Mainly used by the simulator to convert a randomly generated sample into a raw aux time sync set packet\r\n  * @param sample {Buffer} - A sample object\r\n  * @param time {Number} - The time to inject into the sample.\r\n  * @param rawAux {Buffer} - 2 byte buffer to inject into sample\r\n  * @returns {Buffer} - A time sync raw aux packet\r\n  */\n  convertSampleToPacketRawAuxTimeSyncSet: (sample, time, rawAux) => {\n    let buf = convertSampleToPacketRawAuxTimeSynced(sample, time, rawAux);\n    buf[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte] = makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSyncSet);\n    return buf;\n  },\n  convertSampleToPacketRawAuxTimeSynced,\n  debugPrettyPrint: sample => {\n    if (sample === null || sample === undefined) {\n      console.log('== Sample is undefined ==');\n    } else {\n      console.log('-- Sample --');\n      console.log('---- Start Byte: ' + sample.startByte);\n      console.log('---- Sample Number: ' + sample.sampleNumber);\n      for (let i = 0; i < 8; i++) {\n        console.log('---- Channel Data ' + (i + 1) + ': ' + sample.channelData[i]);\n      }\n      if (sample.accelData) {\n        for (let j = 0; j < 3; j++) {\n          console.log('---- Accel Data ' + j + ': ' + sample.accelData[j]);\n        }\n      }\n      if (sample.auxData) {\n        console.log('---- Aux Data ' + sample.auxData);\n      }\n      console.log('---- Stop Byte: ' + sample.stopByte);\n    }\n  },\n  samplePrintHeader: () => {\n    return 'All voltages in Volts!' + 'sampleNumber, channel1, channel2, channel3, channel4, channel5, channel6, channel7, channel8, aux1, aux2, aux3\\n';\n  },\n  samplePrintLine: sample => {\n    return new Promise((resolve, reject) => {\n      if (sample === null || sample === undefined) reject(Error('undefined sample'));\n\n      resolve(sample.sampleNumber + ',' + sample.channelData[0].toFixed(8) + ',' + sample.channelData[1].toFixed(8) + ',' + sample.channelData[2].toFixed(8) + ',' + sample.channelData[3].toFixed(8) + ',' + sample.channelData[4].toFixed(8) + ',' + sample.channelData[5].toFixed(8) + ',' + sample.channelData[6].toFixed(8) + ',' + sample.channelData[7].toFixed(8) + ',' + sample.auxData[0].toFixed(8) + ',' + sample.auxData[1].toFixed(8) + ',' + sample.auxData[2].toFixed(8) + '\\n');\n    });\n  },\n  floatTo3ByteBuffer,\n  floatTo2ByteBuffer,\n  /**\r\n  * @description Calculate the impedance for one channel only.\r\n  * @param sampleObject - Standard OpenBCI sample object\r\n  * @param channelNumber - Number, the channel you want to calculate impedance for.\r\n  * @returns {Promise} - Fulfilled with impedance value for the specified channel.\r\n  * @author AJ Keller\r\n  */\n  impedanceCalculationForChannel: (sampleObject, channelNumber) => {\n    const sqrt2 = Math.sqrt(2);\n    return new Promise((resolve, reject) => {\n      if (sampleObject === undefined || sampleObject === null) reject(Error('Sample Object cannot be null or undefined'));\n      if (sampleObject.channelData === undefined || sampleObject.channelData === null) reject(Error('Channel cannot be null or undefined'));\n      if (channelNumber < 1 || channelNumber > __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault) reject(Error('Channel number invalid.'));\n\n      let index = channelNumber - 1;\n\n      if (sampleObject.channelData[index] < 0) {\n        sampleObject.channelData[index] *= -1;\n      }\n      let impedance = sqrt2 * sampleObject.channelData[index] / __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCILeadOffDriveInAmps;\n      // if (index === 0) console.log(\"Voltage: \" + (sqrt2*sampleObject.channelData[index]) + \" leadoff amps: \" + k.OBCILeadOffDriveInAmps + \" impedance: \" + impedance)\n      resolve(impedance);\n    });\n  },\n  /**\r\n  * @description Calculate the impedance for all channels.\r\n  * @param sampleObject - Standard OpenBCI sample object\r\n  * @returns {Promise} - Fulfilled with impedances for the sample\r\n  * @author AJ Keller\r\n  */\n  impedanceCalculationForAllChannels: sampleObject => {\n    const sqrt2 = Math.sqrt(2);\n    return new Promise((resolve, reject) => {\n      if (sampleObject === undefined || sampleObject === null) reject(Error('Sample Object cannot be null or undefined'));\n      if (sampleObject.channelData === undefined || sampleObject.channelData === null) reject(Error('Channel cannot be null or undefined'));\n\n      let sampleImpedances = [];\n      let numChannels = sampleObject.channelData.length;\n      for (let index = 0; index < numChannels; index++) {\n        if (sampleObject.channelData[index] < 0) {\n          sampleObject.channelData[index] *= -1;\n        }\n        let impedance = sqrt2 * sampleObject.channelData[index] / __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCILeadOffDriveInAmps;\n        sampleImpedances.push(impedance);\n\n        // if (index === 0) console.log(\"Voltage: \" + (sqrt2*sampleObject.channelData[index]) + \" leadoff amps: \" + k.OBCILeadOffDriveInAmps + \" impedance: \" + impedance)\n      }\n\n      sampleObject.impedances = sampleImpedances;\n\n      resolve(sampleObject);\n    });\n  },\n  interpret16bitAsInt32: twoByteBuffer => {\n    let prefix = 0;\n\n    if (twoByteBuffer[0] > 127) {\n      // console.log('\\t\\tNegative number')\n      prefix = 65535; // 0xFFFF\n    }\n\n    return prefix << 16 | twoByteBuffer[0] << 8 | twoByteBuffer[1];\n  },\n  interpret24bitAsInt32: threeByteBuffer => {\n    let prefix = 0;\n\n    if (threeByteBuffer[0] > 127) {\n      // console.log('\\t\\tNegative number')\n      prefix = 255;\n    }\n\n    return prefix << 24 | threeByteBuffer[0] << 16 | threeByteBuffer[1] << 8 | threeByteBuffer[2];\n  },\n  impedanceArray: numberOfChannels => {\n    let impedanceArray = [];\n    for (let i = 0; i < numberOfChannels; i++) {\n      impedanceArray.push(newImpedanceObject(i + 1));\n    }\n    return impedanceArray;\n  },\n  impedanceObject: newImpedanceObject,\n  impedanceSummarize: singleInputObject => {\n    if (singleInputObject.raw > __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIImpedanceThresholdBadMax) {\n      // The case for no load (super high impedance)\n      singleInputObject.text = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIImpedanceTextNone;\n    } else {\n      singleInputObject.text = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].getTextForRawImpedance(singleInputObject.raw); // Get textual impedance\n    }\n  },\n  newSample,\n  newSampleNoScale,\n  /**\r\n  * @description Create a configurable function to return samples for a simulator. This implements 1/f filtering injection to create more brain like data.\r\n  * @param numberOfChannels {Number} - The number of channels in the sample... either 8 or 16\r\n  * @param sampleRateHz {Number} - The sample rate\r\n  * @param injectAlpha {Boolean} (optional) - True if you want to inject noise\r\n  * @param lineNoise {String} (optional) - A string that can be either:\r\n  *              `60Hz` - 60Hz line noise (Default) (ex. __United States__)\r\n  *              `50Hz` - 50Hz line noise (ex. __Europe__)\r\n  *              `none` - Do not inject line noise.\r\n  *\r\n  * @returns {Function}\r\n  */\n  randomSample: (numberOfChannels, sampleRateHz, injectAlpha, lineNoise) => {\n    const distribution = __WEBPACK_IMPORTED_MODULE_0_gaussian___default()(0, 1);\n    const sineWaveFreqHz10 = 10;\n    const sineWaveFreqHz50 = 50;\n    const sineWaveFreqHz60 = 60;\n    const uVolts = 1000000;\n\n    let sinePhaseRad = new Array(numberOfChannels + 1); // prevent index error with '+1'\n    sinePhaseRad.fill(0);\n\n    let auxData = [0, 0, 0];\n    let accelCounter = 0;\n    // With 250Hz, every 10 samples, with 125Hz, every 5...\n    let samplesPerAccelRate = Math.floor(sampleRateHz / 25); // best to make this an integer\n    if (samplesPerAccelRate < 1) samplesPerAccelRate = 1;\n\n    // Init arrays to hold coefficients for each channel and init to 0\n    //  This gives the 1/f filter memory on each iteration\n    let b0 = new Array(numberOfChannels).fill(0);\n    let b1 = new Array(numberOfChannels).fill(0);\n    let b2 = new Array(numberOfChannels).fill(0);\n\n    /**\r\n    * @description Use a 1/f filter\r\n    * @param previousSampleNumber {Number} - The previous sample number\r\n    */\n    return previousSampleNumber => {\n      let sample = newSample();\n      let whiteNoise;\n      for (let i = 0; i < numberOfChannels; i++) {\n        // channels are 0 indexed\n        // This produces white noise\n        whiteNoise = distribution.ppf(Math.random()) * Math.sqrt(sampleRateHz / 2) / uVolts;\n\n        switch (i) {\n          case 0: // Add 10Hz signal to channel 1... brainy\n          case 1:\n            if (injectAlpha) {\n              sinePhaseRad[i] += 2 * Math.PI * sineWaveFreqHz10 / sampleRateHz;\n              if (sinePhaseRad[i] > 2 * Math.PI) {\n                sinePhaseRad[i] -= 2 * Math.PI;\n              }\n              whiteNoise += 5 * Math.SQRT2 * Math.sin(sinePhaseRad[i]) / uVolts;\n            }\n            break;\n          default:\n            if (lineNoise === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISimulatorLineNoiseHz60) {\n              // If we're in murica we want to add 60Hz line noise\n              sinePhaseRad[i] += 2 * Math.PI * sineWaveFreqHz60 / sampleRateHz;\n              if (sinePhaseRad[i] > 2 * Math.PI) {\n                sinePhaseRad[i] -= 2 * Math.PI;\n              }\n              whiteNoise += 8 * Math.SQRT2 * Math.sin(sinePhaseRad[i]) / uVolts;\n            } else if (lineNoise === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISimulatorLineNoiseHz50) {\n              // add 50Hz line noise if we are not in america\n              sinePhaseRad[i] += 2 * Math.PI * sineWaveFreqHz50 / sampleRateHz;\n              if (sinePhaseRad[i] > 2 * Math.PI) {\n                sinePhaseRad[i] -= 2 * Math.PI;\n              }\n              whiteNoise += 8 * Math.SQRT2 * Math.sin(sinePhaseRad[i]) / uVolts;\n            }\n        }\n        /**\r\n        * See http://www.firstpr.com.au/dsp/pink-noise/ section \"Filtering white noise to make it pink\"\r\n        */\n        b0[i] = 0.99765 * b0[i] + whiteNoise * 0.0990460;\n        b1[i] = 0.96300 * b1[i] + whiteNoise * 0.2965164;\n        b2[i] = 0.57000 * b2[i] + whiteNoise * 1.0526913;\n        sample.channelData[i] = b0[i] + b1[i] + b2[i] + whiteNoise * 0.1848;\n      }\n      if (previousSampleNumber === 255) {\n        sample.sampleNumber = 0;\n      } else {\n        sample.sampleNumber = previousSampleNumber + 1;\n      }\n\n      /**\r\n      * Sample rate of accelerometer is 25Hz... when the accelCounter hits the relative sample rate of the accel\r\n      *  we will output a new accel value. The approach will be to consider that Z should be about 1 and X and Y\r\n      *  should be somewhere around 0.\r\n      */\n      if (accelCounter === samplesPerAccelRate) {\n        // Initialize a new array\n        let accelArray = [0, 0, 0];\n        // Calculate X\n        accelArray[0] = Math.random() * 0.1 * (Math.random() > 0.5 ? -1 : 1);\n        // Calculate Y\n        accelArray[1] = Math.random() * 0.1 * (Math.random() > 0.5 ? -1 : 1);\n        // Calculate Z, this is around 1\n        accelArray[2] = 1 - Math.random() * 0.4 * (Math.random() > 0.5 ? -1 : 1);\n        // Store the newly calculated value\n        sample.auxData = accelArray;\n        // Reset the counter\n        accelCounter = 0;\n      } else {\n        // Increment counter\n        accelCounter++;\n        // Store the default value\n        sample.auxData = auxData;\n      }\n\n      return sample;\n    };\n  },\n  scaleFactorAux: SCALE_FACTOR_ACCEL,\n  /**\r\n   * Calculate the impedance\r\n   * @param sample {Object} - Standard sample\r\n   * @param impedanceTest {Object} - Impedance Object from openBCIBoard.js\r\n   * @return {null | Object} - Null if not enough samples have passed to calculate an accurate\r\n   */\n  impedanceCalculateArray: (sample, impedanceTest) => {\n    impedanceTest.buffer.push(sample.channelData);\n    impedanceTest.count++;\n\n    if (impedanceTest.count >= impedanceTest.window) {\n      let output = [];\n      for (let i = 0; i < sample.channelData.length; i++) {\n        let max = 0.0; // sumSquared\n        for (let j = 0; j < impedanceTest.window; j++) {\n          if (impedanceTest.buffer[i][j] > max) {\n            max = impedanceTest.buffer[i][j];\n          }\n        }\n        let min = 0.0;\n        for (let j = 0; j < impedanceTest.window; j++) {\n          if (impedanceTest.buffer[i][j] < min) {\n            min = impedanceTest.buffer[i][j];\n          }\n        }\n        const vP2P = max - min; // peak to peak\n\n        output.push(vP2P / 2 / __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCILeadOffDriveInAmps);\n      }\n      impedanceTest.count = 0;\n      return output;\n    }\n    return null;\n  },\n  impedanceTestObjDefault: impedanceTestObj => {\n    let newObj = impedanceTestObj || {};\n    newObj['active'] = false;\n    newObj['buffer'] = [];\n    newObj['count'] = 0;\n    newObj['isTestingPInput'] = false;\n    newObj['isTestingNInput'] = false;\n    newObj['onChannel'] = 0;\n    newObj['sampleNumber'] = 0;\n    newObj['continuousMode'] = false;\n    newObj['impedanceForChannel'] = 0;\n    newObj['window'] = 40;\n    return newObj;\n  },\n  samplePacket: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0, 0, 0, 1, 0, 2, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardAccel)]);\n  },\n  samplePacketZero: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardAccel)]);\n  },\n  samplePacketReal: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0x8F, 0xF2, 0x40, 0x8F, 0xDF, 0xF4, 0x90, 0x2B, 0xB6, 0x8F, 0xBF, 0xBF, 0x7F, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x94, 0x25, 0x34, 0x20, 0xB6, 0x7D, 0, 0xE0, 0, 0xE0, 0x0F, 0x70, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardAccel)]);\n  },\n  samplePacketStandardRawAux: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0, 1, 2, 3, 4, 5, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardRawAux)]);\n  },\n  samplePacketAccelTimeSyncSet: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0, 1, 0, 0, 0, 1, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSyncSet)]);\n  },\n  samplePacketAccelTimeSynced: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0, 1, 0, 0, 0, 1, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSynced)]);\n  },\n  samplePacketRawAuxTimeSyncSet: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0x00, 0x01, 0, 0, 0, 1, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSyncSet)]);\n  },\n  samplePacketRawAuxTimeSynced: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0, 0, 8, 0x00, 0x01, 0, 0, 0, 1, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSynced)]);\n  },\n  samplePacketImpedance: channelNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, channelNumber, 54, 52, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketImpedance)]);\n  },\n  samplePacketUserDefined: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xA0, 0x00, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketUserDefinedType)]);\n  },\n  samplePacketCytonBLE: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0xC0, sampleNumberNormalize(sampleNumber), 0, 0, 1, 0, 0, 2, 0, 0, 10, 0, 0, 20, 0, 0, 100, 0, 0, 200]);\n  },\n  countADSPresent,\n  doesBufferHaveEOT,\n  getBiasSetFromADSRegisterQuery,\n  getBooleanFromRegisterQuery,\n  getChannelDataArray,\n  getChannelDataArrayNoScale,\n  getDataArrayAccel,\n  getDataArrayAccelNoScale,\n  getFirmware,\n  getSRB1FromADSRegisterQuery,\n  getNumFromThreeCSVADSRegisterQuery,\n  isEven,\n  isFailureInBuffer,\n  isOdd,\n  isStopByte,\n  isSuccessInBuffer,\n  isTimeSyncSetConfirmationInBuffer,\n  makeDaisySampleObject,\n  makeDaisySampleObjectWifi,\n  makeTailByteFromPacketType,\n  newSyncObject,\n  setChSetFromADSRegisterQuery,\n  stripToEOTBuffer,\n  syncChannelSettingsWithRawData,\n  /**\r\n  * @description Checks to make sure the previous sample number is one less\r\n  *  then the new sample number. Takes into account sample numbers wrapping\r\n  *  around at 255.\r\n  * @param `previousSampleNumber` {Number} - An integer number of the previous\r\n  *  sample number.\r\n  * @param `newSampleNumber` {Number} - An integer number of the new sample\r\n  *  number.\r\n  * @returns {Array} - Returns null if there is no dropped packets, otherwise,\r\n  *  or on a missed packet, an array of their packet numbers is returned.\r\n  */\n  droppedPacketCheck: (previousSampleNumber, newSampleNumber) => {\n    if (previousSampleNumber === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISampleNumberMax && newSampleNumber === 0) {\n      return null;\n    }\n\n    if (newSampleNumber - previousSampleNumber === 1) {\n      return null;\n    }\n\n    let missedPacketArray = [];\n\n    if (previousSampleNumber > newSampleNumber) {\n      let numMised = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISampleNumberMax - previousSampleNumber;\n      for (let i = 0; i < numMised; i++) {\n        missedPacketArray.push(previousSampleNumber + i + 1);\n      }\n      previousSampleNumber = -1;\n    }\n\n    for (let j = 1; j < newSampleNumber - previousSampleNumber; j++) {\n      missedPacketArray.push(previousSampleNumber + j);\n    }\n    return missedPacketArray;\n  },\n  convert18bitAsInt32,\n  convert19bitAsInt32,\n  decompressDeltas18Bit,\n  decompressDeltas19Bit,\n  sampleCompressedData: sampleNumber => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([sampleNumber, // 0\n    0b00000000, // 0\n    0b00000000, // 1\n    0b00000000, // 2\n    0b00000000, // 3\n    0b00001000, // 4\n    0b00000000, // 5\n    0b00000101, // 6\n    0b00000000, // 7\n    0b00000000, // 8\n    0b01001000, // 9\n    0b00000000, // 10\n    0b00001001, // 11\n    0b11110000, // 12\n    0b00000001, // 13\n    0b10110000, // 14\n    0b00000000, // 15\n    0b00110000, // 16\n    0b00000000, // 17\n    0b00001000 // 18\n    ]);\n  },\n  sampleBLERaw: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4]);\n  },\n  sampleImpedanceChannel1: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel1, 0, 0, 1]);\n  },\n  sampleImpedanceChannel2: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel2, 0, 0, 1]);\n  },\n  sampleImpedanceChannel3: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel3, 0, 0, 1]);\n  },\n  sampleImpedanceChannel4: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel4, 0, 0, 1]);\n  },\n  sampleImpedanceChannelReference: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannelReference, 0, 0, 1]);\n  },\n  sampleMultiBytePacket: data => {\n    const bufPre = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdMultiPacket]);\n    return __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].concat([bufPre, data]);\n  },\n  sampleMultiBytePacketStop: data => {\n    const bufPre = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdMultiPacketStop]);\n    return __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].concat([bufPre, data]);\n  },\n  sampleOtherData: data => {\n    const bufPre = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([255]);\n    return __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].concat([bufPre, data]);\n  },\n  sampleUncompressedData: () => {\n    return new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([0b00000000, // 0\n    0b00000000, // 1\n    0b00000000, // 2\n    0b00000001, // 3\n    0b00000000, // 4\n    0b00000000, // 5\n    0b00000010, // 6\n    0b00000000, // 7\n    0b00000000, // 8\n    0b00000011, // 9\n    0b00000000, // 10\n    0b00000000, // 11\n    0b00000100, // 12\n    0b00000001, // 13\n    0b00000010, // 14\n    0b00000011, // 15\n    0b00000100, // 16\n    0b00000101, // 17\n    0b00000110, // 18\n    0b00000111 // 19\n    ]);\n  },\n  parseGanglion,\n  processMultiBytePacket,\n  processMultiBytePacketStop\n};\n\n/**\r\n * @description Used transform raw data packets into fully qualified packets\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @return {Array} samples An array of {Sample}\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction parseGanglion(o) {\n  const byteId = parseInt(o.rawDataPacket[0]);\n  if (byteId <= __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteId19Bit.max) {\n    return processRouteSampleData(o);\n  } else {\n    switch (byteId) {\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdMultiPacket:\n        return processMultiBytePacket(o);\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdMultiPacketStop:\n        return processMultiBytePacketStop(o);\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel1:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel2:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel3:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel4:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannelReference:\n        return processImpedanceData(o);\n      default:\n        return null;\n    }\n  }\n}\n\n/**\r\n * Process an compressed packet of data.\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @private\r\n */\nfunction processCompressedData(o) {\n  // Save the packet counter\n  o.lastSampleNumber = parseInt(o.rawDataPacket[0]);\n\n  const samples = [];\n  // Decompress the buffer into array\n  if (o.lastSampleNumber <= __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteId18Bit.max) {\n    decompressSamples(o, decompressDeltas18Bit(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.dataStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.dataStop)));\n    samples.push(buildSample(o.lastSampleNumber * 2 - 1, o.decompressedSamples[1], o.sendCounts));\n    samples.push(buildSample(o.lastSampleNumber * 2, o.decompressedSamples[2], o.sendCounts));\n\n    switch (o.lastSampleNumber % 10) {\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelAxisX:\n        o.accelArray[0] = o.sendCounts ? o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) * __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelScaleFactor;\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelAxisY:\n        o.accelArray[1] = o.sendCounts ? o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) * __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelScaleFactor;\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelAxisZ:\n        o.accelArray[2] = o.sendCounts ? o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) : o.rawDataPacket.readInt8(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket18Bit.auxByte - 1) * __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionAccelScaleFactor;\n        if (o.sendCounts) {\n          samples[0].accelData = o.accelArray;\n        } else {\n          samples[0].accelDataCounts = o.accelArray;\n        }\n        break;\n      default:\n        break;\n    }\n  } else {\n    decompressSamples(o, decompressDeltas19Bit(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStop)));\n\n    samples.push(buildSample((o.lastSampleNumber - 100) * 2 - 1, o.decompressedSamples[1], o.sendCounts));\n    samples.push(buildSample((o.lastSampleNumber - 100) * 2, o.decompressedSamples[2], o.sendCounts));\n  }\n\n  // Rotate the 0 position for next time\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsGanglion; i++) {\n    o.decompressedSamples[0][i] = o.decompressedSamples[2][i];\n  }\n\n  return samples;\n}\n\n/**\r\n * Process and emit an impedance value\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @private\r\n */\nfunction processImpedanceData(o) {\n  const byteId = parseInt(o.rawDataPacket[0]);\n  let channelNumber;\n  switch (byteId) {\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel1:\n      channelNumber = 1;\n      break;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel2:\n      channelNumber = 2;\n      break;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel3:\n      channelNumber = 3;\n      break;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannel4:\n      channelNumber = 4;\n      break;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdImpedanceChannelReference:\n      channelNumber = 0;\n      break;\n  }\n\n  let output = {\n    channelNumber: channelNumber,\n    impedanceValue: 0\n  };\n\n  let end = o.rawDataPacket.length;\n\n  while (Number.isNaN(Number(o.rawDataPacket.slice(1, end))) && end !== 0) {\n    end--;\n  }\n\n  if (end !== 0) {\n    output.impedanceValue = Number(o.rawDataPacket.slice(1, end));\n  }\n\n  return output;\n}\n\n/**\r\n * Used to stack multi packet buffers into the multi packet buffer. This is finally emitted when a stop packet byte id\r\n *  is received.\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @private\r\n */\nfunction processMultiBytePacket(o) {\n  if (o.multiPacketBuffer) {\n    o.multiPacketBuffer = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].concat([__WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(o.multiPacketBuffer), __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStop))]);\n  } else {\n    o.multiPacketBuffer = o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionPacket19Bit.dataStop);\n  }\n}\n\n/**\r\n * Adds the `data` buffer to the multi packet buffer and emits the buffer as 'message'\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @private\r\n */\nfunction processMultiBytePacketStop(o) {\n  processMultiBytePacket(o);\n  const str = o.multiPacketBuffer.toString();\n  o.multiPacketBuffer = null;\n  return {\n    'message': str\n  };\n}\n\n/**\r\n * Utilize `receivedDeltas` to get actual count values.\r\n * @param receivedDeltas {Array} - An array of deltas\r\n *  of shape 2x4 (2 samples per packet and 4 channels per sample.)\r\n * @private\r\n */\nfunction decompressSamples(o, receivedDeltas) {\n  // add the delta to the previous value\n  for (let i = 1; i < 3; i++) {\n    for (let j = 0; j < 4; j++) {\n      o.decompressedSamples[i][j] = o.decompressedSamples[i - 1][j] - receivedDeltas[i - 1][j];\n    }\n  }\n}\n\n/**\r\n * Builds a sample object from an array and sample number.\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @return {Array}\r\n * @private\r\n */\nfunction buildSample(sampleNumber, rawData, sendCounts) {\n  let sample;\n  if (sendCounts) {\n    sample = newSampleNoScale(sampleNumber);\n    sample.channelDataCounts = rawData;\n  } else {\n    sample = newSample(sampleNumber);\n    for (let j = 0; j < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsGanglion; j++) {\n      sample.channelData.push(rawData[j] * __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionScaleFactorPerCountVolts);\n    }\n  }\n  sample.timestamp = Date.now();\n  return sample;\n}\n\n/**\r\n * Used to route samples for Ganglion\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @returns {*}\r\n */\nfunction processRouteSampleData(o) {\n  if (parseInt(o.rawDataPacket[0]) === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdUncompressed) {\n    return processUncompressedData(o);\n  } else {\n    return processCompressedData(o);\n  }\n}\n\n/**\r\n * Process an uncompressed packet of data.\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @private\r\n */\nfunction processUncompressedData(o) {\n  // Resets the packet counter back to zero\n  o.lastSampleNumber = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionByteIdUncompressed; // used to find dropped packets\n\n  for (let i = 0; i < 4; i++) {\n    o.decompressedSamples[0][i] = utilitiesModule.interpret24bitAsInt32(o.rawDataPacket.slice(1 + i * 3, 1 + i * 3 + 3)); // seed the decompressor\n  }\n\n  return [buildSample(0, o.decompressedSamples[0], o.sendCounts)];\n}\n\n/**\r\n * Converts a special ganglion 18 bit compressed number\r\n *  The compressions uses the LSB, bit 1, as the signed bit, instead of using\r\n *  the MSB. Therefore you must not look to the MSB for a sign extension, one\r\n *  must look to the LSB, and the same rules applies, if it's a 1, then it's a\r\n *  negative and if it's 0 then it's a positive number.\r\n * @param threeByteBuffer {Buffer}\r\n *  A 3-byte buffer with only 18 bits of actual data.\r\n * @return {number} A signed integer.\r\n */\nfunction convert18bitAsInt32(threeByteBuffer) {\n  let prefix = 0;\n\n  if (threeByteBuffer[2] & 0x01 > 0) {\n    // console.log('\\t\\tNegative number')\n    prefix = 0b11111111111111;\n  }\n\n  return prefix << 18 | threeByteBuffer[0] << 16 | threeByteBuffer[1] << 8 | threeByteBuffer[2];\n}\n\n/**\r\n * Converts a special ganglion 19 bit compressed number\r\n *  The compressions uses the LSB, bit 1, as the signed bit, instead of using\r\n *  the MSB. Therefore you must not look to the MSB for a sign extension, one\r\n *  must look to the LSB, and the same rules applies, if it's a 1, then it's a\r\n *  negative and if it's 0 then it's a positive number.\r\n * @param threeByteBuffer {Buffer}\r\n *  A 3-byte buffer with only 19 bits of actual data.\r\n * @return {number} A signed integer.\r\n */\nfunction convert19bitAsInt32(threeByteBuffer) {\n  let prefix = 0;\n\n  if (threeByteBuffer[2] & 0x01 > 0) {\n    // console.log('\\t\\tNegative number')\n    prefix = 0b1111111111111;\n  }\n\n  return prefix << 19 | threeByteBuffer[0] << 16 | threeByteBuffer[1] << 8 | threeByteBuffer[2];\n}\n\n/**\r\n * Called to when a compressed packet is received.\r\n * @param buffer {Buffer} Just the data portion of the sample. So 18 bytes.\r\n * @return {Array} - An array of deltas of shape 2x4 (2 samples per packet\r\n *  and 4 channels per sample.)\r\n * @private\r\n */\nfunction decompressDeltas18Bit(buffer) {\n  let D = new Array(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionSamplesPerPacket); // 2\n  D[0] = [0, 0, 0, 0];\n  D[1] = [0, 0, 0, 0];\n\n  let receivedDeltas = [];\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionSamplesPerPacket; i++) {\n    receivedDeltas.push([0, 0, 0, 0]);\n  }\n\n  let miniBuf;\n\n  // Sample 1 - Channel 1\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[0] >> 6, (buffer[0] & 0x3F) << 2 | buffer[1] >> 6, (buffer[1] & 0x3F) << 2 | buffer[2] >> 6]);\n  receivedDeltas[0][0] = convert18bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 2\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[2] & 0x3F) >> 4, buffer[2] << 4 | buffer[3] >> 4, buffer[3] << 4 | buffer[4] >> 4]);\n  // miniBuf = new Buffer([(buffer[2] & 0x1F), buffer[3], buffer[4] >> 2]);\n  receivedDeltas[0][1] = convert18bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 3\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[4] & 0x0F) >> 2, buffer[4] << 6 | buffer[5] >> 2, buffer[5] << 6 | buffer[6] >> 2]);\n  receivedDeltas[0][2] = convert18bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 4\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[6] & 0x03, buffer[7], buffer[8]]);\n  receivedDeltas[0][3] = convert18bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 1\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[9] >> 6, (buffer[9] & 0x3F) << 2 | buffer[10] >> 6, (buffer[10] & 0x3F) << 2 | buffer[11] >> 6]);\n  receivedDeltas[1][0] = convert18bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 2\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[11] & 0x3F) >> 4, buffer[11] << 4 | buffer[12] >> 4, buffer[12] << 4 | buffer[13] >> 4]);\n  receivedDeltas[1][1] = convert18bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 3\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[13] & 0x0F) >> 2, buffer[13] << 6 | buffer[14] >> 2, buffer[14] << 6 | buffer[15] >> 2]);\n  receivedDeltas[1][2] = convert18bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 4\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[15] & 0x03, buffer[16], buffer[17]]);\n  receivedDeltas[1][3] = convert18bitAsInt32(miniBuf);\n\n  return receivedDeltas;\n}\n\n/**\r\n * Called to when a compressed packet is received.\r\n * @param buffer {Buffer} Just the data portion of the sample. So 19 bytes.\r\n * @return {Array} - An array of deltas of shape 2x4 (2 samples per packet\r\n *  and 4 channels per sample.)\r\n * @private\r\n */\nfunction decompressDeltas19Bit(buffer) {\n  let D = new Array(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionSamplesPerPacket); // 2\n  D[0] = [0, 0, 0, 0];\n  D[1] = [0, 0, 0, 0];\n\n  let receivedDeltas = [];\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionSamplesPerPacket; i++) {\n    receivedDeltas.push([0, 0, 0, 0]);\n  }\n\n  let miniBuf;\n\n  // Sample 1 - Channel 1\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[0] >> 5, (buffer[0] & 0x1F) << 3 | buffer[1] >> 5, (buffer[1] & 0x1F) << 3 | buffer[2] >> 5]);\n  receivedDeltas[0][0] = convert19bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 2\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[2] & 0x1F) >> 2, buffer[2] << 6 | buffer[3] >> 2, buffer[3] << 6 | buffer[4] >> 2]);\n  // miniBuf = new Buffer([(buffer[2] & 0x1F), buffer[3], buffer[4] >> 2]);\n  receivedDeltas[0][1] = convert19bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 3\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[4] & 0x03) << 1 | buffer[5] >> 7, (buffer[5] & 0x7F) << 1 | buffer[6] >> 7, (buffer[6] & 0x7F) << 1 | buffer[7] >> 7]);\n  receivedDeltas[0][2] = convert19bitAsInt32(miniBuf);\n\n  // Sample 1 - Channel 4\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[7] & 0x7F) >> 4, (buffer[7] & 0x0F) << 4 | buffer[8] >> 4, (buffer[8] & 0x0F) << 4 | buffer[9] >> 4]);\n  receivedDeltas[0][3] = convert19bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 1\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[9] & 0x0F) >> 1, buffer[9] << 7 | buffer[10] >> 1, buffer[10] << 7 | buffer[11] >> 1]);\n  receivedDeltas[1][0] = convert19bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 2\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[11] & 0x01) << 2 | buffer[12] >> 6, buffer[12] << 2 | buffer[13] >> 6, buffer[13] << 2 | buffer[14] >> 6]);\n  receivedDeltas[1][1] = convert19bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 3\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([(buffer[14] & 0x38) >> 3, (buffer[14] & 0x07) << 5 | (buffer[15] & 0xF8) >> 3, (buffer[15] & 0x07) << 5 | (buffer[16] & 0xF8) >> 3]);\n  receivedDeltas[1][2] = convert19bitAsInt32(miniBuf);\n\n  // Sample 2 - Channel 4\n  miniBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]([buffer[16] & 0x07, buffer[17], buffer[18]]);\n  receivedDeltas[1][3] = convert19bitAsInt32(miniBuf);\n\n  return receivedDeltas;\n}\n\nfunction newImpedanceObject(channelNumber) {\n  return {\n    channel: channelNumber,\n    P: {\n      raw: -1,\n      text: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIImpedanceTextInit\n    },\n    N: {\n      raw: -1,\n      text: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIImpedanceTextInit\n    }\n  };\n}\n\nfunction newSyncObject() {\n  return {\n    boardTime: 0,\n    correctedTransmissionTime: false,\n    error: null,\n    timeSyncSent: 0,\n    timeSyncSentConfirmation: 0,\n    timeSyncSetPacket: 0,\n    timeRoundTrip: 0,\n    timeTransmission: 0,\n    timeOffset: 0,\n    timeOffsetMaster: 0,\n    valid: false\n  };\n}\n\n/**\r\n * @description Used transform raw data packets into fully qualified packets\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @return {Array} samples An array of {Sample}\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction transformRawDataPacketsToSample(o) {\n  let samples = [];\n  for (let i = 0; i < o.rawDataPackets.length; i++) {\n    o.rawDataPacket = o.rawDataPackets[i];\n    const sample = transformRawDataPacketToSample(o);\n    samples.push(sample);\n    if (sample.hasOwnProperty('sampleNumber')) {\n      o['lastSampleNumber'] = sample.sampleNumber;\n    } else if (!sample.hasOwnProperty('impedanceValue')) {\n      o['lastSampleNumber'] = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n    }\n  }\n  return samples;\n}\n\n/**\r\n * @description Used transform raw data packets into fully qualified packets\r\n * @param o {RawDataToSample} - Used to hold data and configuration settings\r\n * @return {Array} samples An array of {Sample}\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction transformRawDataPacketToSample(o) {\n  let sample;\n  try {\n    const packetType = getRawPacketType(o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte]);\n    switch (packetType) {\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardAccel:\n        sample = utilitiesModule.parsePacketStandardAccel(o);\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardRawAux:\n        sample = utilitiesModule.parsePacketStandardRawAux(o);\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSyncSet:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSynced:\n        sample = utilitiesModule.parsePacketTimeSyncedAccel(o);\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSyncSet:\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSynced:\n        sample = utilitiesModule.parsePacketTimeSyncedRawAux(o);\n        break;\n      case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketImpedance:\n        sample = utilitiesModule.parsePacketImpedance(o);\n        break;\n      default:\n        // Don't do anything if the packet is not defined\n        sample = {\n          error: `bad stop byte ${o.rawDataPacket.slice(32, 33).toString('hex')}`,\n          valid: false,\n          rawDataPacket: o.rawDataPacket\n        };\n        if (o.verbose) console.log(sample.error);\n        break;\n    }\n  } catch (err) {\n    sample = {\n      error: err,\n      valid: false,\n      rawDataPacket: o.rawDataPacket\n    };\n    if (o.verbose) console.log(err);\n  }\n  return sample;\n}\n\n/**\r\n * Used to convert a ganglions decompressed back into a buffer\r\n * @param arr {Array} - An array of four numbers\r\n * @param data {Buffer} - A buffer to store into\r\n */\nfunction convertGanglionArrayToBuffer(arr, data) {\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsGanglion; i++) {\n    data.writeInt16BE(arr[i] >> 8, i * 3);\n    data.writeInt8(arr[i] & 255, i * 3 + 2);\n  }\n}\n\n/**\r\n * @description This function takes a raw data buffer of 4 3-byte signed integers for ganglion\r\n * @param o {Object} - The input object\r\n * @param o.data {Buffer} - An allocated and filled buffer of length 12\r\n * @param o.rawDataPacket {Buffer} - An allocated buffer of length 33\r\n * @param o.sampleNumber {Number} - The sample number to load into the `rawDataPacket`\r\n */\nfunction ganglionFillRawDataPacket(o) {\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.data) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.data)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure sampleNumber is inside object\n  if (!o.hasOwnProperty('sampleNumber')) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the rawDataPacket buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  // Check to make sure the rawDataPacket buffer is the right size.\n  if (o.data.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSizeBLERaw) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n\n  o.data.copy(o.rawDataPacket, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart);\n  o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber] = o.sampleNumber;\n  o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStartByte] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n  o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketStandardRawAux;\n}\n\n/**\r\n * @description This method parses a 33 byte OpenBCI V3 packet and converts to a sample object\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling k.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default true\r\n * @param o.lastSampleNumber {Number} - The last sample number\r\n * @returns {Sample} - A sample object. NOTE: Only has accelData if this is a Z axis packet.\r\n */\nfunction parsePacketStandardAccel(o) {\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  // Verify the correct stop byte.\n  if (o.rawDataPacket[0] !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteStart);\n\n  const sampleObject = {};\n\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.scale) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.scale)) o.scale = true;\n\n  if (o.scale) sampleObject.accelData = getDataArrayAccel(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStartAux, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopAux + 1));else sampleObject.accelDataCounts = getDataArrayAccelNoScale(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStartAux, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopAux + 1));\n\n  if (o.scale) sampleObject.channelData = getChannelDataArray(o);else sampleObject.channelDataCounts = getChannelDataArrayNoScale(o);\n\n  sampleObject.auxData = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStartAux, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopAux + 1));\n\n  // Get the sample number\n  sampleObject.sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  // Get the start byte\n  sampleObject.startByte = o.rawDataPacket[0];\n  // Get the stop byte\n  sampleObject.stopByte = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte];\n\n  sampleObject.valid = true;\n\n  sampleObject.timestamp = Date.now();\n  sampleObject.boardTime = 0;\n\n  return sampleObject;\n}\n\n/**\r\n * @description This method parses a 33 byte OpenBCI V3 packet and converts to a sample object\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling k.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default is true\r\n * @param o.lastSampleNumber {Number} - The last sample number\r\n * @returns {Sample} - A sample object. NOTE: Only has accelData if this is a Z axis packet.\r\n */\nfunction parsePacketStandardRawAux(o) {\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  // Verify the correct stop byte.\n  if (o.rawDataPacket[0] !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteStart);\n\n  const sampleObject = {};\n\n  // Store the channel data\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.scale) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.scale)) o.scale = true;\n  if (o.scale) sampleObject.channelData = getChannelDataArray(o);else sampleObject.channelDataCounts = getChannelDataArrayNoScale(o);\n\n  // Slice the buffer for the aux data\n  sampleObject.auxData = __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(o.rawDataPacket.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStartAux, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopAux + 1));\n\n  // Get the sample number\n  sampleObject.sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  // Get the start byte\n  sampleObject.startByte = o.rawDataPacket[0];\n  // Get the stop byte\n  sampleObject.stopByte = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte];\n\n  sampleObject.valid = true;\n\n  sampleObject.timestamp = Date.now();\n  sampleObject.boardTime = 0;\n\n  return sampleObject;\n}\n\n/**\r\n * @description Grabs an accel value from a raw but time synced packet. Important that this utilizes the fact that:\r\n *      X axis data is sent with every sampleNumber % 10 === 0\r\n *      Y axis data is sent with every sampleNumber % 10 === 1\r\n *      Z axis data is sent with every sampleNumber % 10 === 2\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling OpenBCIConstans.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @param o.timeOffset {Number} - The difference between board time and current time calculated with sync methods.\r\n * @param o.accelArray {Array} - A 3 element array that allows us to have inter packet memory of x and y axis data and emit only on the z axis packets.\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default is true\r\n * @returns {Sample} - A sample object. NOTE: Only has accelData if this is a Z axis packet.\r\n */\nfunction parsePacketTimeSyncedAccel(o) {\n  // Ths packet has 'A0','00'....,'AA','AA','FF','FF','FF','FF','C4'\n  //  where the 'AA's form an accel 16bit num and 'FF's form a 32 bit time in ms\n  // The sample object we are going to build\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  // Verify the correct stop byte.\n  if (o.rawDataPacket[0] !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteStart);\n\n  let sampleObject = {};\n\n  // Get the sample number\n  sampleObject.sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  // Get the start byte\n  sampleObject.startByte = o.rawDataPacket[0];\n  // Get the stop byte\n  sampleObject.stopByte = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte];\n\n  // Get the board time\n  sampleObject.boardTime = getFromTimePacketTime(o.rawDataPacket);\n  if (o.hasOwnProperty('timeOffset')) {\n    sampleObject.timestamp = sampleObject.boardTime + o.timeOffset;\n  } else {\n    sampleObject.timestamp = Date.now();\n  }\n\n  // Extract the aux data\n  sampleObject.auxData = getFromTimePacketRawAux(o.rawDataPacket);\n\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.scale) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.scale)) o.scale = true;\n  if (o.scale) sampleObject.channelData = getChannelDataArray(o);else sampleObject.channelDataCounts = getChannelDataArrayNoScale(o);\n\n  // Grab the accelData only if `getFromTimePacketAccel` returns true.\n  if (getFromTimePacketAccel(o)) {\n    if (o.scale) sampleObject.accelData = o.accelArray;else sampleObject.accelDataCounts = o.accelArray;\n  }\n\n  sampleObject.valid = true;\n\n  return sampleObject;\n}\n\n/**\r\n * @description Raw aux\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling k.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @param o.timeOffset {Number} - The difference between board time and current time calculated with sync methods.\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default is true\r\n * @param o.lastSampleNumber {Number} - The last sample number\r\n * @returns {Sample} - A sample object. NOTE: The aux data is placed in a 2 byte buffer\r\n */\nfunction parsePacketTimeSyncedRawAux(o) {\n  // Ths packet has 'A0','00'....,'AA','AA','FF','FF','FF','FF','C4'\n  //  where the 'AA's form an accel 16bit num and 'FF's form a 32 bit time in ms\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  // Verify the correct stop byte.\n  if (o.rawDataPacket[0] !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteStart);\n\n  // The sample object we are going to build\n  let sampleObject = {};\n\n  // Get the sample number\n  sampleObject.sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  // Get the start byte\n  sampleObject.startByte = o.rawDataPacket[0];\n  // Get the stop byte\n  sampleObject.stopByte = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionStopByte];\n\n  // Get the board time\n  sampleObject.boardTime = getFromTimePacketTime(o.rawDataPacket);\n  if (o.hasOwnProperty('timeOffset')) {\n    sampleObject.timestamp = sampleObject.boardTime + o.timeOffset;\n  } else {\n    sampleObject.timestamp = Date.now();\n  }\n\n  // Extract the aux data\n  sampleObject.auxData = getFromTimePacketRawAux(o.rawDataPacket);\n\n  // Grab the channel data.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.scale) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.scale)) o.scale = true;\n  if (o.scale) sampleObject.channelData = getChannelDataArray(o);else sampleObject.channelDataCounts = getChannelDataArrayNoScale(o);\n\n  sampleObject.valid = true;\n\n  return sampleObject;\n}\n\n/**\r\n * @description Raw aux\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @returns {Impedance} - An impedance object.\r\n */\nfunction parsePacketImpedance(o) {\n  // Ths packet has 'A0','00'....,'AA','AA','FF','FF','FF','FF','C4'\n  //  where the 'AA's form an accel 16bit num and 'FF's form a 32 bit time in ms\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.rawDataPacket) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.rawDataPacket)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure the buffer is the right size.\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n\n  let impedanceObject = {};\n\n  impedanceObject.channelNumber = o.rawDataPacket[1];\n  if (impedanceObject.channelNumber === 5) {\n    impedanceObject.channelNumber = 0;\n  }\n  impedanceObject.impedanceValue = Number(o.rawDataPacket.toString().match(/\\d+/)[0]);\n\n  return impedanceObject;\n}\n\n/**\r\n * Use reg ex to parse a `str` register query for a boolean `offset` from index. Throws errors\r\n * @param str {String} - The string to search\r\n * @param regEx {RegExp} - The key to match to\r\n * @param offset {Number} - The number of bytes to offset from the index of the reg ex hit\r\n * @returns {boolean} The converted and parsed value from `str`\r\n */\nfunction getBooleanFromRegisterQuery(str, regEx, offset) {\n  let regExArr = str.match(regEx);\n  if (regExArr) {\n    const num = parseInt(str.charAt(regExArr.index + offset));\n    if (!Number.isNaN(num)) {\n      return Boolean(num);\n    } else {\n      throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidData);\n    }\n  } else {\n    throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorMissingRegisterSetting);\n  }\n}\n\n/**\r\n * Used to get the truth value fo srb1 within the system\r\n * @param str {String} - The raw query data\r\n * @returns {boolean}\r\n */\nfunction getSRB1FromADSRegisterQuery(str) {\n  return getBooleanFromRegisterQuery(str, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryNameMISC1, 21);\n}\n\n/**\r\n * Used to get bias setting from raw query\r\n * @param str {String} - The raw query data\r\n * @param channelNumber {Number} - Zero indexed, please send `channelNumber` directly to this function.\r\n * @returns {boolean}\r\n */\nfunction getBiasSetFromADSRegisterQuery(str, channelNumber) {\n  return getBooleanFromRegisterQuery(str, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryNameBIASSENSP, 20 + channelNumber * 3);\n}\n\n/**\r\n * Used to get a number from the raw query data\r\n * @param str {String} - The raw query data\r\n * @param regEx {RegExp} - The regular expression to index off of\r\n * @param offset {Number} - The number of bytes offset from index to start\r\n */\nfunction getNumFromThreeCSVADSRegisterQuery(str, regEx, offset) {\n  let regExArr = str.match(regEx);\n  if (regExArr) {\n    const bit2 = parseInt(str.charAt(regExArr.index + offset));\n    const bit1 = parseInt(str.charAt(regExArr.index + offset + 3));\n    const bit0 = parseInt(str.charAt(regExArr.index + offset + 6));\n    if (!Number.isNaN(bit2) && !Number.isNaN(bit1) && !Number.isNaN(bit0)) {\n      return bit2 << 2 | bit1 << 1 | bit0;\n    } else {\n      throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidData);\n    }\n  } else {\n    throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorMissingRegisterSetting);\n  }\n}\n\n/**\r\n * Used to get bias setting from raw query\r\n * @param str {String} - The raw query data\r\n * @param channelSettings {ChannelSettingsObject} - Just your standard channel setting object\r\n * @returns {boolean}\r\n */\nfunction setChSetFromADSRegisterQuery(str, channelSettings) {\n  let key = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryNameCHnSET[channelSettings.channelNumber];\n  if (key === undefined) key = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryNameCHnSET[channelSettings.channelNumber - __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton];\n  channelSettings.powerDown = getBooleanFromRegisterQuery(str, key, 16);\n  channelSettings.gain = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].gainForCommand(getNumFromThreeCSVADSRegisterQuery(str, key, 19));\n  channelSettings.inputType = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].inputTypeForCommand(getNumFromThreeCSVADSRegisterQuery(str, key, 31));\n  channelSettings.srb2 = getBooleanFromRegisterQuery(str, key, 28);\n}\n\n/**\r\n *\r\n * @param o {Object}\r\n * @param o.channelSettings {Array} - The standard channel settings object\r\n * @param o.data {Buffer} - The buffer of raw query data\r\n */\nfunction syncChannelSettingsWithRawData(o) {\n  // Check to make sure data is not null.\n  if (__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.channelSettings) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.channelSettings) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isUndefined(o.data) || __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNull(o.data)) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorUndefinedOrNullInput);\n  // Check to make sure channel settings is array\n  if (!Array.isArray(o.channelSettings)) throw new Error(`${__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidType} channelSettings`);\n  // Check to make sure the rawDataPacket buffer is the right size.\n\n  if (o.channelSettings.length === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton) {\n    if (o.data.toString().match(/Daisy ADS/)) throw new Error('raw data mismatch - expected only cyton register info but also found daisy');\n    if (o.data.toString().match(/Board ADS/) == null) throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidData);\n  } else {\n    if (o.data.toString().match(/Daisy ADS/) == null) throw new Error('raw data mismatch - expected daisy register info but none found');\n    if (o.data.toString().match(/Board ADS/) == null) throw new Error('no Board ADS info found');\n  }\n\n  o.channelSettings.forEach(cs => {\n    if (!cs.hasOwnProperty('channelNumber') || !cs.hasOwnProperty('powerDown') || !cs.hasOwnProperty('gain') || !cs.hasOwnProperty('inputType') || !cs.hasOwnProperty('bias') || !cs.hasOwnProperty('srb2') || !cs.hasOwnProperty('srb1')) {\n      throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorMissingRequiredProperty);\n    }\n  });\n\n  let adsDaisy = null;\n  let usingSRB1Cyton = false;\n  let usingSRB1Daisy = false;\n  let regExArr = o.data.toString().match(/Board ADS/);\n  let adsCyton = o.data.toString().slice(regExArr.index, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryCyton.length);\n  if (getSRB1FromADSRegisterQuery(adsCyton)) {\n    usingSRB1Cyton = true;\n  }\n  if (o.channelSettings.length > __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton) {\n    let regExArrDaisy = o.data.toString().match(/Daisy ADS/);\n    adsDaisy = o.data.toString().slice(regExArrDaisy.index, regExArrDaisy.index + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIRegisterQueryCytonDaisy.length);\n    if (getSRB1FromADSRegisterQuery(adsCyton)) {\n      usingSRB1Daisy = true;\n    }\n  }\n  o.channelSettings.forEach(\n  /**\r\n   * Set each channel\r\n   * @param cs {ChannelSettingsObject}\r\n   */\n  cs => {\n    if (cs.channelNumber < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton) {\n      setChSetFromADSRegisterQuery(adsCyton, cs);\n      cs.bias = getBiasSetFromADSRegisterQuery(adsCyton, cs.channelNumber);\n      cs.srb1 = usingSRB1Cyton;\n    } else {\n      setChSetFromADSRegisterQuery(adsDaisy, cs);\n      cs.bias = getBiasSetFromADSRegisterQuery(adsDaisy, cs.channelNumber - __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton);\n      cs.srb1 = usingSRB1Daisy;\n    }\n  });\n}\n\n/**\r\n* @description Extract a time from a time packet in ms.\r\n* @param dataBuf - A raw packet with 33 bytes of data\r\n* @returns {Number} - Board time in milli seconds\r\n* @author AJ Keller (@aj-ptw)\r\n*/\nfunction getFromTimePacketTime(dataBuf) {\n  // Ths packet has 'A0','00'....,'00','00','FF','FF','FF','FF','C3' where the 'FF's are times\n  const lastBytePosition = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1; // This is 33, but 0 indexed would be 32 minus 1 for the stop byte and another two for the aux channel or the\n  if (dataBuf.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) {\n    throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  } else {\n    // Grab the time from the packet\n    return dataBuf.readUInt32BE(lastBytePosition - __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketTimeByteSize);\n  }\n}\n\n/**\r\n * @description Grabs an accel value from a raw but time synced packet. Important that this utilizes the fact that:\r\n *      X axis data is sent with every sampleNumber % 10 === 7\r\n *      Y axis data is sent with every sampleNumber % 10 === 8\r\n *      Z axis data is sent with every sampleNumber % 10 === 9\r\n * @param o {Object}\r\n * @param o.accelArray {Array} - A 3 element array that allows us to have inter packet memory of x and y axis data and emit only on the z axis packets.\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default is true\r\n * @returns {boolean} - A boolean that is true only when the accel array is ready to be emitted... i.e. when this is a Z axis packet\r\n */\nfunction getFromTimePacketAccel(o) {\n  const accelNumBytes = 2;\n  const lastBytePosition = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1 - __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketTimeByteSize - accelNumBytes; // This is 33, but 0 indexed would be 32 minus\n\n  if (o.rawDataPacket.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) {\n    throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  }\n\n  let sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  let accelCountValue = utilitiesModule.interpret16bitAsInt32(o.rawDataPacket.slice(lastBytePosition, lastBytePosition + 2));\n  switch (sampleNumber % 10) {// The accelerometer is on a 25Hz sample rate, so every ten channel samples, we can get new data\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIAccelAxisX:\n      o.accelArray[0] = o.scale ? accelCountValue * SCALE_FACTOR_ACCEL : accelCountValue; // slice is not inclusive on the right\n      return false;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIAccelAxisY:\n      o.accelArray[1] = o.scale ? accelCountValue * SCALE_FACTOR_ACCEL : accelCountValue; // slice is not inclusive on the right\n      return false;\n    case __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIAccelAxisZ:\n      o.accelArray[2] = o.scale ? accelCountValue * SCALE_FACTOR_ACCEL : accelCountValue; // slice is not inclusive on the right\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\r\n* @description Grabs a raw aux value from a raw but time synced packet.\r\n* @param dataBuf {Buffer} - The 33byte raw time synced raw aux packet\r\n* @returns {Buffer|SafeBuffer|Buffer2} - Fulfills a 2 byte buffer\r\n*/\nfunction getFromTimePacketRawAux(dataBuf) {\n  if (dataBuf.byteLength !== __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize) {\n    throw new Error(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIErrorInvalidByteLength);\n  }\n  return __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuf.slice(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionTimeSyncAuxStart, __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionTimeSyncAuxStop));\n}\n\n/**\r\n* @description Takes a buffer filled with 3 16 bit integers from an OpenBCI device and converts based on settings\r\n*                  of the MPU, values are in ?\r\n* @param dataBuf - Buffer that is 6 bytes long\r\n* @returns {Array} - Array of floats 3 elements long\r\n* @author AJ Keller (@aj-ptw)\r\n*/\nfunction getDataArrayAccel(dataBuf) {\n  let accelData = [];\n  for (let i = 0; i < ACCEL_NUMBER_AXIS; i++) {\n    let index = i * 2;\n    accelData.push(utilitiesModule.interpret16bitAsInt32(dataBuf.slice(index, index + 2)) * SCALE_FACTOR_ACCEL);\n  }\n  return accelData;\n}\n\n/**\r\n * @description Takes a buffer filled with 3 16 bit integers from an OpenBCI device and converts based on settings\r\n *                  to an int\r\n * @param dataBuf - Buffer that is 6 bytes long\r\n * @returns {Array} - Array of floats 3 elements long\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction getDataArrayAccelNoScale(dataBuf) {\n  let accelData = [];\n  for (let i = 0; i < ACCEL_NUMBER_AXIS; i++) {\n    let index = i * 2;\n    accelData.push(utilitiesModule.interpret16bitAsInt32(dataBuf.slice(index, index + 2)));\n  }\n  return accelData;\n}\n\n/**\r\n * @description Takes a buffer filled with 24 bit signed integers from an OpenBCI device with gain settings in\r\n *                  channelSettingsArray[index].gain and converts based on settings of ADS1299... spits out an\r\n *                  array of floats in VOLTS\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling k.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @param o.scale {Boolean} - Do you want to scale the results? Default is true\r\n * @param o.lastSampleNumber {Number} - The last sample number\r\n * @param o.protocol {String} - Either `Serial` or `Wifi` (Default is `Wifi`)\r\n * @returns {Array} - Array filled with floats for each channel's voltage in VOLTS\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction getChannelDataArray(o) {\n  if (!Array.isArray(o.channelSettings)) {\n    throw new Error('Error [getChannelDataArray]: Channel Settings must be an array!');\n  }\n  if (!o.hasOwnProperty('protocol')) {\n    o.protocol = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIProtocolSerial;\n  }\n  let channelData = [];\n  // Grab the sample number from the buffer\n  const numChannels = o.channelSettings.length;\n  const sampleNumber = o.rawDataPacket[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionSampleNumber];\n  const daisy = numChannels === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDaisy;\n  let channelsInPacket = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton;\n  if (!daisy) channelsInPacket = o.channelSettings.length;\n  // Channel data arrays are always 8 long\n  for (let i = 0; i < channelsInPacket; i++) {\n    if (!o.channelSettings[i].hasOwnProperty('gain')) {\n      throw new Error(`Error [getChannelDataArray]: Invalid channel settings object at index ${i}`);\n    }\n    if (!__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].isNumber(o.channelSettings[i].gain)) {\n      throw new Error('Error [getChannelDataArray]: Property gain of channelSettingsObject not or type Number');\n    }\n\n    let scaleFactor = 0;\n\n    if (o.protocol === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIProtocolSerial) {\n      if (isEven(sampleNumber) && daisy) {\n        scaleFactor = ADS1299_VREF / o.channelSettings[i + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault].gain / (Math.pow(2, 23) - 1);\n      } else {\n        scaleFactor = ADS1299_VREF / o.channelSettings[i].gain / (Math.pow(2, 23) - 1);\n      }\n    } else if (o.protocol === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIProtocolWifi) {\n      if (daisy) {\n        if (o.lastSampleNumber === sampleNumber) {\n          scaleFactor = ADS1299_VREF / o.channelSettings[i + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault].gain / (Math.pow(2, 23) - 1);\n        } else {\n          scaleFactor = ADS1299_VREF / o.channelSettings[i].gain / (Math.pow(2, 23) - 1);\n        }\n      } else if (o.channelSettings.length === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsCyton) {\n        scaleFactor = ADS1299_VREF / o.channelSettings[i].gain / (Math.pow(2, 23) - 1);\n      } else {\n        scaleFactor = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIGanglionScaleFactorPerCountVolts;\n      }\n    } else if (o.protocol === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIProtocolBLE) {\n      // For cyton ble not ganglion\n      scaleFactor = ADS1299_VREF / o.channelSettings[i].gain / (Math.pow(2, 23) - 1);\n    } else {\n      throw new Error('Error [getChannelDataArray]: Invalid protocol must be wifi or serial');\n    }\n\n    // Convert the three byte signed integer and convert it\n    channelData.push(scaleFactor * utilitiesModule.interpret24bitAsInt32(o.rawDataPacket.slice(i * 3 + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart, i * 3 + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart + 3)));\n  }\n  return channelData;\n}\n\n/**\r\n * @description Takes a buffer filled with 24 bit signed integers from an OpenBCI device converts to array of counts\r\n * @param o {Object} - The input object\r\n * @param o.rawDataPacket {Buffer} - The 33byte raw time synced accel packet\r\n * @param o.channelSettings {Array} - An array of channel settings that is an Array that has shape similar to the one\r\n *                  calling k.channelSettingsArrayInit(). The most important rule here is that it is\r\n *                  Array of objects that have key-value pair {gain:NUMBER}\r\n * @returns {Array} - Array filled with floats for each channel's voltage in VOLTS\r\n * @author AJ Keller (@aj-ptw)\r\n */\nfunction getChannelDataArrayNoScale(o) {\n  if (!Array.isArray(o.channelSettings)) {\n    throw new Error('Error [getChannelDataArrayNoScale]: Channel Settings must be an array!');\n  }\n  let channelData = [];\n  let numChannels = o.channelSettings.length;\n  if (numChannels > __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault) {\n    numChannels = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault;\n  }\n  // Channel data arrays cannot be more than 8\n  for (let i = 0; i < numChannels; i++) {\n    // Convert the three byte signed integer and convert it\n    channelData.push(utilitiesModule.interpret24bitAsInt32(o.rawDataPacket.slice(i * 3 + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart, i * 3 + __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketPositionChannelDataStart + 3)));\n  }\n  return channelData;\n}\n\nfunction getRawPacketType(stopByte) {\n  return stopByte & 0xF;\n}\n\n/**\r\n* @description This method is useful for normalizing sample numbers for fake sample packets. This is intended to be\r\n*      useful for the simulator and automated testing.\r\n* @param sampleNumber {Number} - The sample number you want to assign to the packet\r\n* @returns {Number} - The normalized input `sampleNumber` between 0-255\r\n*/\nfunction sampleNumberNormalize(sampleNumber) {\n  if (sampleNumber || sampleNumber === 0) {\n    if (sampleNumber > 255) {\n      sampleNumber = 255;\n    }\n  } else {\n    sampleNumber = 0x45;\n  }\n  return sampleNumber;\n}\n\nfunction newSample(sampleNumber) {\n  if (sampleNumber || sampleNumber === 0) {\n    if (sampleNumber > 255) {\n      sampleNumber = 255;\n    }\n  } else {\n    sampleNumber = 0;\n  }\n  return {\n    startByte: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart,\n    sampleNumber: sampleNumber,\n    channelData: [],\n    accelData: [],\n    auxData: null,\n    stopByte: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStop,\n    boardTime: 0,\n    timestamp: 0,\n    valid: true\n  };\n}\n\nfunction newSampleNoScale(sampleNumber) {\n  if (sampleNumber || sampleNumber === 0) {\n    if (sampleNumber > 255) {\n      sampleNumber = 255;\n    }\n  } else {\n    sampleNumber = 0;\n  }\n  return {\n    startByte: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart,\n    sampleNumber: sampleNumber,\n    channelDataCounts: [],\n    accelDataCounts: [],\n    auxData: null,\n    stopByte: __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStop,\n    boardTime: 0,\n    timestamp: 0,\n    valid: true\n  };\n}\n\n/**\r\n* @description Convert float number into three byte buffer. This is the opposite of .interpret24bitAsInt32()\r\n* @param float - The number you want to convert\r\n* @returns {Buffer} - 3-byte buffer containing the float\r\n*/\nfunction floatTo3ByteBuffer(float) {\n  let intBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](3); // 3 bytes for 24 bits\n  intBuf.fill(0); // Fill the buffer with 0s\n\n  let temp = float / (ADS1299_VREF / 24 / (Math.pow(2, 23) - 1)); // Convert to counts\n\n  temp = Math.floor(temp); // Truncate counts number\n\n  // Move into buffer\n  intBuf[2] = temp & 255;\n  intBuf[1] = (temp & 255 << 8) >> 8;\n  intBuf[0] = (temp & 255 << 16) >> 16;\n\n  return intBuf;\n}\n\n/**\r\n* @description Convert float number into three byte buffer. This is the opposite of .interpret24bitAsInt32()\r\n* @param float - The number you want to convert\r\n* @returns {buffer} - 3-byte buffer containing the float\r\n*/\nfunction floatTo2ByteBuffer(float) {\n  let intBuf = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](2); // 2 bytes for 16 bits\n  intBuf.fill(0); // Fill the buffer with 0s\n\n  let temp = float / SCALE_FACTOR_ACCEL; // Convert to counts\n\n  temp = Math.floor(temp); // Truncate counts number\n\n  // console.log('Num: ' + temp)\n\n  // Move into buffer\n  intBuf[1] = temp & 255;\n  intBuf[0] = (temp & 255 << 8) >> 8;\n\n  return intBuf;\n}\n\n/**\r\n* @description Used to make one sample object from two sample objects. The sample number of the new daisy sample will\r\n*      be the upperSampleObject's sample number divded by 2. This allows us to preserve consecutive sample numbers that\r\n*      flip over at 127 instead of 255 for an 8 channel. The daisySampleObject will also have one `channelData` array\r\n*      with 16 elements inside it, with the lowerSampleObject in the lower indices and the upperSampleObject in the\r\n*      upper set of indices. The auxData from both channels shall be captured in an object called `auxData` which\r\n*      contains two arrays referenced by keys `lower` and `upper` for the `lowerSampleObject` and `upperSampleObject`,\r\n*      respectively. The timestamps shall be averaged and moved into an object called `timestamp`. Further, the\r\n*      un-averaged timestamps from the `lowerSampleObject` and `upperSampleObject` shall be placed into an object called\r\n*      `_timestamps` which shall contain two keys `lower` and `upper` which contain the original timestamps for their\r\n*      respective sampleObjects.\r\n* @param lowerSampleObject {Object} - Lower 8 channels with odd sample number\r\n* @param upperSampleObject {Object} - Upper 8 channels with even sample number\r\n* @returns {Object} - The new merged daisy sample object\r\n*/\nfunction makeDaisySampleObject(lowerSampleObject, upperSampleObject) {\n  let daisySampleObject = {};\n\n  if (lowerSampleObject.hasOwnProperty('channelData')) {\n    daisySampleObject.channelData = lowerSampleObject.channelData.concat(upperSampleObject.channelData);\n  }\n\n  if (lowerSampleObject.hasOwnProperty('channelDataCounts')) {\n    daisySampleObject.channelDataCounts = lowerSampleObject.channelDataCounts.concat(upperSampleObject.channelDataCounts);\n  }\n\n  daisySampleObject.sampleNumber = Math.floor(upperSampleObject.sampleNumber / 2);\n\n  daisySampleObject.auxData = {\n    'lower': lowerSampleObject.auxData,\n    'upper': upperSampleObject.auxData\n  };\n\n  daisySampleObject.stopByte = lowerSampleObject.stopByte;\n\n  daisySampleObject.timestamp = (lowerSampleObject.timestamp + upperSampleObject.timestamp) / 2;\n\n  daisySampleObject['_timestamps'] = {\n    'lower': lowerSampleObject.timestamp,\n    'upper': upperSampleObject.timestamp\n  };\n\n  if (lowerSampleObject.hasOwnProperty('accelData')) {\n    if (lowerSampleObject.accelData[0] > 0 || lowerSampleObject.accelData[1] > 0 || lowerSampleObject.accelData[2] > 0) {\n      daisySampleObject.accelData = lowerSampleObject.accelData;\n    } else {\n      daisySampleObject.accelData = upperSampleObject.accelData;\n    }\n  }\n\n  if (lowerSampleObject.hasOwnProperty('accelDataCounts')) {\n    if (lowerSampleObject.accelDataCounts[0] > 0 || lowerSampleObject.accelDataCounts[1] > 0 || lowerSampleObject.accelDataCounts[2] > 0) {\n      daisySampleObject.accelDataCounts = lowerSampleObject.accelDataCounts;\n    } else {\n      daisySampleObject.accelDataCounts = upperSampleObject.accelDataCounts;\n    }\n  }\n\n  daisySampleObject.valid = true;\n\n  return daisySampleObject;\n}\n\n/**\r\n * @description Used to make one sample object from two sample objects. The sample number of the new daisy sample will\r\n *      be the upperSampleObject's sample number divded by 2. This allows us to preserve consecutive sample numbers that\r\n *      flip over at 127 instead of 255 for an 8 channel. The daisySampleObject will also have one `channelData` array\r\n *      with 16 elements inside it, with the lowerSampleObject in the lower indices and the upperSampleObject in the\r\n *      upper set of indices. The auxData from both channels shall be captured in an object called `auxData` which\r\n *      contains two arrays referenced by keys `lower` and `upper` for the `lowerSampleObject` and `upperSampleObject`,\r\n *      respectively. The timestamps shall be averaged and moved into an object called `timestamp`. Further, the\r\n *      un-averaged timestamps from the `lowerSampleObject` and `upperSampleObject` shall be placed into an object called\r\n *      `_timestamps` which shall contain two keys `lower` and `upper` which contain the original timestamps for their\r\n *      respective sampleObjects.\r\n * @param lowerSampleObject {Object} - Lower 8 channels with odd sample number\r\n * @param upperSampleObject {Object} - Upper 8 channels with even sample number\r\n * @returns {Object} - The new merged daisy sample object\r\n */\nfunction makeDaisySampleObjectWifi(lowerSampleObject, upperSampleObject) {\n  let daisySampleObject = {};\n\n  if (lowerSampleObject.hasOwnProperty('channelData')) {\n    daisySampleObject['channelData'] = lowerSampleObject.channelData.concat(upperSampleObject.channelData);\n  }\n\n  if (lowerSampleObject.hasOwnProperty('channelDataCounts')) {\n    daisySampleObject['channelDataCounts'] = lowerSampleObject.channelDataCounts.concat(upperSampleObject.channelDataCounts);\n  }\n\n  daisySampleObject['sampleNumber'] = upperSampleObject.sampleNumber;\n\n  daisySampleObject['auxData'] = {\n    'lower': lowerSampleObject.auxData,\n    'upper': upperSampleObject.auxData\n  };\n\n  if (lowerSampleObject.hasOwnProperty('timestamp')) {\n    daisySampleObject['timestamp'] = lowerSampleObject.timestamp;\n  }\n\n  daisySampleObject.stopByte = lowerSampleObject.stopByte;\n\n  daisySampleObject['_timestamps'] = {\n    'lower': lowerSampleObject.timestamp,\n    'upper': upperSampleObject.timestamp\n  };\n\n  if (lowerSampleObject.hasOwnProperty('accelData')) {\n    if (lowerSampleObject.accelData[0] > 0 || lowerSampleObject.accelData[1] > 0 || lowerSampleObject.accelData[2] > 0) {\n      daisySampleObject.accelData = lowerSampleObject.accelData;\n    } else {\n      daisySampleObject.accelData = upperSampleObject.accelData;\n    }\n  }\n\n  if (lowerSampleObject.hasOwnProperty('accelDataCounts')) {\n    if (lowerSampleObject.accelDataCounts[0] > 0 || lowerSampleObject.accelDataCounts[1] > 0 || lowerSampleObject.accelDataCounts[2] > 0) {\n      daisySampleObject.accelDataCounts = lowerSampleObject.accelDataCounts;\n    } else {\n      daisySampleObject.accelDataCounts = upperSampleObject.accelDataCounts;\n    }\n  }\n\n  daisySampleObject['valid'] = true;\n\n  return daisySampleObject;\n}\n\n/**\r\n* @description Used to test a number to see if it is even\r\n* @param a {Number} - The number to test\r\n* @returns {boolean} - True if `a` is even\r\n*/\nfunction isEven(a) {\n  return a % 2 === 0;\n}\n/**\r\n* @description Used to test a number to see if it is odd\r\n* @param a {Number} - The number to test\r\n* @returns {boolean} - True if `a` is odd\r\n*/\nfunction isOdd(a) {\n  return a % 2 === 1;\n}\n\n/**\r\n* @description Since we know exactly what this input will look like (See the hardware firmware) we can program this\r\n*      function with prior knowledge.\r\n* @param dataBuffer {Buffer} - The buffer you want to parse.\r\n* @return {Number} - The number of \"ADS1299\" present in the `dataBuffer`\r\n*/\nfunction countADSPresent(dataBuffer) {\n  const s = new __WEBPACK_IMPORTED_MODULE_2_streamsearch___default.a(new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"]('ADS1299'));\n\n  // Clear the buffer\n  s.reset();\n\n  // Push the new data buffer. This runs the search.\n  s.push(dataBuffer);\n\n  // Check and see if there is a match\n  return s.matches;\n}\n\n/**\r\n* @description Searchs the buffer for a \"$$$\" or as we call an EOT\r\n* @param dataBuffer - The buffer of some length to parse\r\n* @returns {boolean} - True if the `$$$` was found.\r\n*/\n// TODO: StreamSearch is optimized to search incoming chunks of data, streaming in,\n//       but a new search is constructed here with every call.  This is not making use\n//       of StreamSearch's optimizations; the object should be preserved between chunks,\n//       and only fed the new data.  TODO: also check other uses of StreamSearch\nfunction doesBufferHaveEOT(dataBuffer) {\n  const s = new __WEBPACK_IMPORTED_MODULE_2_streamsearch___default.a(new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIParseEOT));\n\n  // Clear the buffer\n  s.reset();\n\n  // Push the new data buffer. This runs the search.\n  s.push(dataBuffer);\n\n  // Check and see if there is a match\n  return s.matches >= 1;\n}\n\n/**\r\n * Used to extract the major version from\r\n * @param dataBuffer\r\n * @return {*}\r\n */\nfunction getFirmware(dataBuffer) {\n  const regexPattern = /v\\d.\\d*.\\d*/;\n  const ret = dataBuffer.toString().match(regexPattern);\n  if (ret) {\n    const elems = ret[0].split('.');\n    return {\n      major: Number(elems[0][1]),\n      minor: Number(elems[1]),\n      patch: Number(elems[2]),\n      raw: ret[0]\n    };\n  } else return ret;\n}\n\n/**\r\n* @description Used to parse a buffer for the word `Failure` that is acked back after private radio msg on failure\r\n* @param dataBuffer {Buffer} - The buffer of some length to parse\r\n* @returns {boolean} - True if `Failure` was found.\r\n*/\nfunction isFailureInBuffer(dataBuffer) {\n  const s = new __WEBPACK_IMPORTED_MODULE_2_streamsearch___default.a(new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIParseFailure));\n\n  // Clear the buffer\n  s.reset();\n\n  // Push the new data buffer. This runs the search.\n  s.push(dataBuffer);\n\n  // Check and see if there is a match\n  return s.matches >= 1;\n}\n\n/**\r\n* @description Used to parse a buffer for the word `Success` that is acked back after private radio msg on success\r\n* @param dataBuffer {Buffer} - The buffer of some length to parse\r\n* @returns {boolean} - True if `Success` was found.\r\n*/\nfunction isSuccessInBuffer(dataBuffer) {\n  const s = new __WEBPACK_IMPORTED_MODULE_2_streamsearch___default.a(new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIParseSuccess));\n\n  // Clear the buffer\n  s.reset();\n\n  // Push the new data buffer. This runs the search.\n  s.push(dataBuffer);\n\n  // Check and see if there is a match\n  return s.matches >= 1;\n}\n\n/**\r\n * @description Used to slice a buffer for the EOT '$$$'.\r\n * @param dataBuffer {Buffer} - The buffer of some length to parse\r\n * @returns {Buffer} - The remaining buffer.\r\n */\nfunction stripToEOTBuffer(dataBuffer) {\n  let indexOfEOT = dataBuffer.indexOf(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIParseEOT);\n  if (indexOfEOT >= 0) {\n    indexOfEOT += __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIParseEOT.length;\n  } else {\n    return dataBuffer;\n  }\n\n  if (indexOfEOT < dataBuffer.byteLength) {\n    return __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"].from(dataBuffer.slice(indexOfEOT));\n  } else {\n    return null;\n  }\n}\n\n/**\r\n* @description Used to parse a buffer for the `,` character that is acked back after a time sync request is sent\r\n* @param dataBuffer {Buffer} - The buffer of some length to parse\r\n* @returns {boolean} - True if the `,` was found.\r\n*/\nfunction isTimeSyncSetConfirmationInBuffer(dataBuffer) {\n  if (dataBuffer) {\n    let bufferLength = dataBuffer.length;\n    switch (bufferLength) {\n      case 0:\n        return false;\n      case 1:\n        return dataBuffer[0] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0);\n      case 2:\n        // HEAD Byte at End\n        if (dataBuffer[1] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) {\n          return dataBuffer[0] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0);\n          // TAIL byte in front\n        } else if (isStopByte(dataBuffer[0])) {\n          return dataBuffer[1] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0);\n        } else {\n          return false;\n        }\n      default:\n        if (dataBuffer[0] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0) && dataBuffer[1] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) {\n          return true;\n        }\n        for (let i = 1; i < bufferLength; i++) {\n          // The base case (last one)\n          // console.log(i)\n          if (i === bufferLength - 1) {\n            if (isStopByte(dataBuffer[i - 1])) {\n              return dataBuffer[i] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0);\n            }\n          } else {\n            // Wedged\n            if (isStopByte(dataBuffer[i - 1]) && dataBuffer[i + 1] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart) {\n              return dataBuffer[i] === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCISyncTimeSent.charCodeAt(0);\n              // TAIL byte in front\n            }\n          }\n        }\n        return false;\n    }\n  }\n}\n\n/**\r\n* @description Mainly used by the simulator to convert a randomly generated sample into a std OpenBCI V3 Packet\r\n* @param sample {Object} - A sample object\r\n* @param time {Number} - The time to inject into the sample.\r\n* @param rawAux {Buffer} - 2 byte buffer to inject into sample\r\n* @returns {Buffer} - A time sync raw aux packet\r\n*/\nfunction convertSampleToPacketRawAuxTimeSynced(sample, time, rawAux) {\n  let packetBuffer = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize);\n  packetBuffer.fill(0);\n\n  // start byte\n  packetBuffer[0] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n\n  // sample number\n  packetBuffer[1] = sample.sampleNumber;\n\n  // channel data\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault; i++) {\n    let threeByteBuffer = floatTo3ByteBuffer(sample.channelData[i]);\n\n    threeByteBuffer.copy(packetBuffer, 2 + i * 3);\n  }\n\n  // Write the raw aux bytes\n  rawAux.copy(packetBuffer, 26);\n\n  // Write the time\n  packetBuffer.writeInt32BE(time, 28);\n\n  // stop byte\n  packetBuffer[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1] = makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketRawAuxTimeSynced);\n\n  return packetBuffer;\n}\n\n/**\r\n* @description Mainly used by the simulator to convert a randomly generated sample into a std OpenBCI V3 Packet\r\n* @param sample {Object} - A sample object\r\n* @param time {Number} - The time to inject into the sample.\r\n* @returns {Buffer} - A time sync accel packet\r\n*/\nfunction convertSampleToPacketAccelTimeSynced(sample, time) {\n  let packetBuffer = new __WEBPACK_IMPORTED_MODULE_3_buffer___[\"Buffer\"](__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize);\n  packetBuffer.fill(0);\n\n  // start byte\n  packetBuffer[0] = __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStart;\n\n  // sample number\n  packetBuffer[1] = sample.sampleNumber;\n\n  // channel data\n  for (let i = 0; i < __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCINumberOfChannelsDefault; i++) {\n    let threeByteBuffer = floatTo3ByteBuffer(sample.channelData[i]);\n\n    threeByteBuffer.copy(packetBuffer, 2 + i * 3);\n  }\n\n  packetBuffer.writeInt32BE(time, 28);\n\n  // stop byte\n  packetBuffer[__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIPacketSize - 1] = makeTailByteFromPacketType(__WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIStreamPacketAccelTimeSynced);\n\n  return packetBuffer;\n}\n\n/**\r\n* @description Converts a packet type {Number} into a OpenBCI stop byte\r\n* @param type {Number} - The number to smash on to the stop byte. Must be 0-15,\r\n*          out of bounds input will result in a 0\r\n* @return {Number} - A properly formatted OpenBCI stop byte\r\n*/\nfunction makeTailByteFromPacketType(type) {\n  if (type < 0 || type > 15) {\n    type = 0;\n  }\n  return __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStop | type;\n}\n\n/**\r\n* @description Used to check and see if a byte adheres to the stop byte structure of 0xCx where x is the set of\r\n*      numbers from 0-F in hex of 0-15 in decimal.\r\n* @param byte {Number} - The number to test\r\n* @returns {boolean} - True if `byte` follows the correct form\r\n* @author AJ Keller (@aj-ptw)\r\n*/\nfunction isStopByte(byte) {\n  return (byte & 0xF0) === __WEBPACK_IMPORTED_MODULE_1__constants__[\"default\"].OBCIByteStop;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (utilitiesModule);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utilities.js\n// module id = 7\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./src/utilities.js?");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(exports) {\n\n  // Complementary error function\n  // From Numerical Recipes in C 2e p221\n  var erfc = function(x) {\n    var z = Math.abs(x);\n    var t = 1 / (1 + z / 2);\n    var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +\n            t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +\n            t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +\n            t * (-0.82215223 + t * 0.17087277)))))))))\n    return x >= 0 ? r : 2 - r;\n  };\n\n  // Inverse complementary error function\n  // From Numerical Recipes 3e p265\n  var ierfc = function(x) {\n    if (x >= 2) { return -100; }\n    if (x <= 0) { return 100; }\n\n    var xx = (x < 1) ? x : 2 - x;\n    var t = Math.sqrt(-2 * Math.log(xx / 2));\n\n    var r = -0.70711 * ((2.30753 + t * 0.27061) /\n            (1 + t * (0.99229 + t * 0.04481)) - t);\n\n    for (var j = 0; j < 2; j++) {\n      var err = erfc(r) - xx;\n      r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);\n    }\n\n    return (x < 1) ? r : -r;\n  };\n\n  // Models the normal distribution\n  var Gaussian = function(mean, variance) {\n    if (variance <= 0) {\n      throw new Error('Variance must be > 0 (but was ' + variance + ')');\n    }\n    this.mean = mean;\n    this.variance = variance;\n    this.standardDeviation = Math.sqrt(variance);\n  }\n\n  // Probability density function\n  Gaussian.prototype.pdf = function(x) {\n    var m = this.standardDeviation * Math.sqrt(2 * Math.PI);\n    var e = Math.exp(-Math.pow(x - this.mean, 2) / (2 * this.variance));\n    return e / m;\n  };\n\n  // Cumulative density function\n  Gaussian.prototype.cdf = function(x) {\n    return 0.5 * erfc(-(x - this.mean) / (this.standardDeviation * Math.sqrt(2)));\n  };\n\n  // Percent point function\n  Gaussian.prototype.ppf = function(x) {\n    return this.mean - this.standardDeviation * Math.sqrt(2) * ierfc(2 * x);\n  };\n\n  // Product distribution of this and d (scale for constant)\n  Gaussian.prototype.mul = function(d) {\n    if (typeof(d) === \"number\") {\n      return this.scale(d);\n    }\n    var precision = 1 / this.variance;\n    var dprecision = 1 / d.variance;\n    return fromPrecisionMean(\n        precision + dprecision, \n        precision * this.mean + dprecision * d.mean);\n  };\n\n  // Quotient distribution of this and d (scale for constant)\n  Gaussian.prototype.div = function(d) {\n    if (typeof(d) === \"number\") {\n      return this.scale(1 / d);\n    }\n    var precision = 1 / this.variance;\n    var dprecision = 1 / d.variance;\n    return fromPrecisionMean(\n        precision - dprecision, \n        precision * this.mean - dprecision * d.mean);\n  };\n\n  // Addition of this and d\n  Gaussian.prototype.add = function(d) {\n    return gaussian(this.mean + d.mean, this.variance + d.variance);\n  };\n\n  // Subtraction of this and d\n  Gaussian.prototype.sub = function(d) {\n    return gaussian(this.mean - d.mean, this.variance + d.variance);\n  };\n\n  // Scale this by constant c\n  Gaussian.prototype.scale = function(c) {\n    return gaussian(this.mean * c, this.variance * c * c);\n  };\n\n  var gaussian = function(mean, variance) {\n    return new Gaussian(mean, variance);\n  };\n\n  var fromPrecisionMean = function(precision, precisionmean) {\n    return gaussian(precisionmean / precision, 1 / precision);\n  };\n\n  exports(gaussian);\n})\n( true\n    ? function(e) { module.exports = e; }\n    : function(e) { this[\"gaussian\"] = e; });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/gaussian/lib/gaussian.js\n// module id = 8\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/gaussian/lib/gaussian.js?");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = __webpack_require__(10).EventEmitter,\n    inherits = __webpack_require__(11).inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/streamsearch/lib/sbmh.js\n// module id = 9\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/streamsearch/lib/sbmh.js?");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 10\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(13);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(14);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/util.js\n// module id = 11\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 12\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/util/support/isBufferBrowser.js\n// module id = 13\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/inherits/inherits_browser.js\n// module id = 14\n// module chunks = 0 1\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__debug__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utilities__ = __webpack_require__(7);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  constants: __WEBPACK_IMPORTED_MODULE_0__constants__[\"default\"],\n  debug: __WEBPACK_IMPORTED_MODULE_1__debug__,\n  utilities: __WEBPACK_IMPORTED_MODULE_2__utilities__[\"default\"]\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })
/******/ ])["default"];